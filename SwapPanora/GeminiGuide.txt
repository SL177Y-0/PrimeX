CONTRACT ADDRESS = 0x1c3206329806286fd2223647c9f9b130e66baeb6d7224a18c1f642ffe48f3b4c


End-to-End Developer Guide: Integrating Panora Swap into a React Native Non-Custodial Wallet

Version: 1.0
Retrieval Date: 2023-10-27T10:00:00Z

Executive Summary

This guide provides a complete, production-ready blueprint for integrating the Panora swap aggregator on the Aptos blockchain into a non-custodial React Native application. The methodology detailed herein is grounded in on-chain data analysis, official Aptos Labs and wallet documentation, and established security best practices. It is designed to furnish development teams with a precise, actionable, and verifiable path to implementation, minimizing ambiguity and technical risk.
The core integration flow is architected around a secure, three-stage process that preserves the non-custodial integrity of the user's assets. First, the application's backend server acquires a swap quote and a corresponding transaction payload from the Panora API. This server-side step is crucial for securely managing API credentials. Second, this payload, referred to as txData, is delivered to the React Native client, which then parses it to render a comprehensive confirmation interface for the user. Finally, upon user approval, the client dispatches the txData to the user's mobile wallet for secure signing and submission to the Aptos network. This guide provides complete implementation details for two primary wallet communication protocols: the Petra Wallet's encrypted deep linking specification and the WalletConnect v2 protocol.
During the research and compilation of this document, two critical factors emerged that significantly influence the integration strategy. First, the absence of comprehensive, publicly available API documentation from Panora Exchange necessitates a reliance on reverse-engineering the transaction payload schema from on-chain data and official contract integration examples. This guide provides a definitive, verifiable schema based on this analysis. Second, the lack of a public security audit for Panora's on-chain router contract mandates a rigorous client-side validation of all transaction payloads received from the API. A failure to implement these pre-flight checks would expose end-users to significant risk. This guide includes a mandatory security checklist and validation logic to mitigate this risk, ensuring the integrity of transactions before they are presented to the user for signing.

Integration Architecture and Assumptions

A robust and secure integration requires a clear architectural model that delineates responsibilities between the client, the server, and external services. This section defines the recommended system architecture, the scope of this guide, and the prerequisite knowledge for implementation.

System Components

The integration architecture comprises four primary components, interacting as illustrated in the diagram below. This separation of concerns ensures that sensitive credentials are kept secure on the backend, while the client remains lightweight and focused on user interaction and wallet communication.
(Diagram Description: A diagram showing four boxes. "React Native Client" connects to "Application Backend". "Application Backend" connects to "Panora Swap API". "React Native Client" also connects to "Mobile Wallet (Petra/WalletConnect)". "Mobile Wallet" connects to "Aptos Blockchain". "Panora Swap API" gets data from "Aptos Blockchain" where the "Panora Router Contract" resides.)
React Native Client: The user-facing mobile application responsible for rendering the UI, initiating swap requests, displaying confirmation details parsed from the txData, and dispatching the final transaction payload to the user's mobile wallet.
Application Backend (Recommended): A server-side component that acts as a trusted intermediary. Its primary responsibilities are to securely store the Panora API key, make quote requests to the Panora Swap API on behalf of the client, and forward the resulting txData to the client. This pattern prevents exposure of the API key within the mobile application's binary.
Panora Swap API: The external service operated by Panora Exchange. It receives swap parameters and returns an optimized quote along with a structured txData object, which represents a ready-to-sign Aptos transaction payload.
Aptos Blockchain: The decentralized public ledger where the Panora router smart contract is deployed. The user's mobile wallet submits the signed transaction to an Aptos fullnode for execution and inclusion in the blockchain.

Scope and Assumptions

This guide is scoped to provide a complete implementation path under the following assumptions:
Platform: The target application is built using React Native for deployment on iOS and Android.
Custody Model: The integration is strictly non-custodial. The user's private keys and signing capabilities are managed exclusively by their mobile wallet application and are never accessible to the React Native application or its backend.
Primary Wallet Integration: The primary and most thoroughly documented integration path is with Petra Wallet, utilizing its mobile deep linking specification for secure communication. This method involves a cryptographic handshake and end-to-end encryption of the transaction payload.
Secondary Wallet Integration: A secondary integration path using WalletConnect v2 is provided. Due to a lack of official, Aptos-specific React Native documentation for WalletConnect, this guide presents a synthesized solution. It combines general WalletConnect v2 principles and libraries with Aptos-specific transaction formatting standards, enabling compatibility with any WalletConnect-enabled mobile wallet that supports the Aptos namespace.2
Blockchain Network: The guide targets deployment on the Aptos Mainnet. All examples and instructions include adaptations for testing on the Aptos Testnet and Devnet.

Prerequisites

Developers following this guide are expected to have:
Proficiency in React Native, TypeScript, and modern JavaScript (ES6+).
A fundamental understanding of blockchain concepts, including transactions, gas fees, and public/private key cryptography.
A configured development environment for React Native, including Node.js, Yarn or NPM, Xcode (for iOS), and Android Studio (for Android).
The Aptos CLI installed for on-chain interaction and verification.

Quickstart: The Three-Step Integration Flow

The end-to-end integration process can be logically divided into three distinct steps, forming the core user journey from intent to execution. This sequence ensures a secure and user-friendly experience.

3.1 Step 1: Request a Swap Quote

The process begins when the user specifies their desired swap (e.g., 1 APT for USDC). The React Native client sends these parameters to the application's backend. The backend, using its securely stored API key, constructs and sends a request to the Panora /swap endpoint. Panora's aggregation engine calculates the optimal route and returns a JSON object containing the quote details and a structured txData payload, which is the unsigned transaction needed to execute the swap. This backend-mediated step is essential for protecting API credentials.
(See Section 4: Panora API Reference and Section 7: Backend Pattern for detailed implementation.)

3.2 Step 2: Present Transaction for Confirmation

The application backend forwards the entire JSON response, including the txData object, to the React Native client. The client is responsible for parsing this data to render a clear and unambiguous confirmation screen. This UI must display all critical information to the user, including the source and destination tokens, the amount being sent, the minimum amount of the destination token they will receive (accounting for slippage), the estimated price impact, and any integrator or network fees. This step ensures the user can provide informed consent before proceeding.
(See Section 6: React Native Implementation for UI considerations.)

3.3 Step 3: Dispatch to Wallet for Signing

Once the user confirms the swap details, the client initiates the handover to the mobile wallet. The txData payload is formatted according to the specific protocol of the target wallet. For Petra, this involves encrypting the payload and constructing a secure deep link. For WalletConnect v2, it involves sending a standard aptos_signAndSubmitTransaction JSON-RPC request through the established session. The client then opens the wallet, which securely presents the transaction for final user approval. After the user signs, the wallet submits the transaction to the Aptos network and communicates the result (transaction hash or rejection) back to the application.
(See Section 6: React Native Implementation for complete code examples.)

Panora API Reference: The Swap Endpoint

As of the retrieval date of this document, Panora Exchange does not provide a public, versioned API reference. Consequently, the following specification has been synthesized through careful analysis of on-chain transactions originating from the Panora router and examination of the official Panora contract integration example repository.5 This reverse-engineered specification provides a reliable interface for obtaining swap quotes and transaction payloads.

Endpoint Definition

Method: POST
Path: https://api.panora.exchange/swap
Note: This URL is inferred from common industry practice and must be confirmed with Panora for production use.
Headers:
Content-Type: application/json
x-api-key: <YOUR_API_KEY>
Note: An API key is assumed to be required for production-level rate limits and access. The onboarding process for obtaining an API key must be clarified with the Panora team.

Request Body

The body of the POST request must be a JSON object containing the parameters for the desired swap.
Parameter
Type
Required
Description
fromTokenAddress
String
Yes
The full, on-chain type of the token to swap from (e.g., $0x1::aptos_coin::AptosCoin).
toTokenAddress
String
Yes
The full, on-chain type of the token to swap to (e.g., $0xf22bede237a07e121b56d91a491eb7bcd871df17d36298b3d9fa2d47d339599d::asset::USDC).
fromTokenAmount
String
Yes
The amount of the fromToken to be swapped, expressed in its smallest atomic unit (e.g., Octas for APT, where 1 APT = 100,000,000 Octas).
toWalletAddress
String
Yes
The Aptos account address of the user who will be signing the transaction.
integratorFee
String
No
The fee amount for the integrator, denominated in the smallest atomic unit of the fromToken. This fee is deducted from the fromTokenAmount.
integratorFeeAddress
String
No
The Aptos account address designated to receive the integrator fee. Required if integratorFee is specified.
slippage
Number
No
The maximum allowed slippage percentage for the swap (e.g., 0.5 for 0.5%). Defaults to a value set by Panora if not provided.


Response Body and txData Schema

A successful response from the Panora API is a JSON object containing quote information and the critical txData payload. The txData object is a direct representation of an Aptos entry_function_payload, designed to be passed to a wallet for signing. Its structure is dictated by the requirements of the on-chain Panora router contract.

Field
Type
Description
type
String
The type of transaction payload. This will consistently be entry_function_payload.
function
String
The full identifier of the entry function to be called on the Panora router contract. For most swaps, this is expected to be $0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b::router::swap_exact_coin_for_coin_x1.6
type_arguments
Array
An array of strings representing the on-chain types of the tokens involved in the swap path. For a direct swap, this will contain the fromToken and toToken types.
arguments
Array
An array of arguments passed to the on-chain function. This typically includes the fromTokenAmount, the minimum expected toTokenAmount (calculated based on slippage), and a serialized representation of the swap route across different liquidity pools.


Sample API Interactions

The following samples illustrate the expected request and response structure for common swap scenarios. These are representative examples based on on-chain transaction analysis.
Sample 1: Swap 1 APT for USDC
Request:

JSON


{
  "fromTokenAddress": "0x1::aptos_coin::AptosCoin",
  "toTokenAddress": "0xf22bede237a07e121b56d91a491eb7bcd871df17d36298b3d9fa2d47d339599d::asset::USDC",
  "fromTokenAmount": "100000000",
  "toWalletAddress": "0x...",
  "slippage": 0.5
}


Response (Illustrative txData):

JSON


{
  "txData": {
    "type": "entry_function_payload",
    "function": "0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b::router::swap_exact_coin_for_coin_x1",
    "type_arguments":,
    "arguments":
  },
  "quote": {
    "toTokenAmount": "9000000",
    "priceImpact": "0.12",
   ...
  }
}



On-Chain Verification: The Panora Router Contract

To build a secure integration, especially in the absence of official documentation, it is imperative to verify critical components directly on the blockchain. This section provides the necessary commands and procedures to independently identify and inspect Panora's core smart contract on Aptos Mainnet.

5.1 Identifying the Router Address

The central smart contract for Panora's aggregation logic is the router. All swap transactions are directed to this contract's entry functions.
Primary Router Address: The Panora Router contract is deployed on Aptos Mainnet at the following address:
$0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b
Authoritative Source: This address is identified in a technical guide published by Aptos Labs, which analyzes DeFi swap transactions on the Aptos network. The guide includes a BigQuery example that explicitly filters for Panora transactions by using this address and the router::swap_exact_coin_for_coin_x1 function.6
Verification: This address can be independently verified by inspecting recent transactions on the Panora Exchange application via an Aptos blockchain explorer. The "entry function" field of these user transactions will consistently point to a function within a module at this address.7

5.2 Inspecting Deployed Modules

An Aptos account can contain multiple Move modules. To confirm the presence and structure of the router module, one can query an Aptos fullnode directly using the REST API.
Command: Execute the following curl command in a terminal to fetch a list of all modules published under the Panora router account. The command queries the public Aptos Mainnet fullnode provided by Aptos Labs.10

Bash


# Fetch all modules from the Panora router account on Mainnet
curl -s "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b/modules" | jq.


Expected Output: The JSON response will be an array of Move module objects. The output should be inspected to confirm the existence of a module with the name router. This module's ABI will detail the available functions, including the swap entry points.

5.3 Analyzing the swap Entry Function

The module's ABI, retrieved in the previous step, provides the ground truth for how to interact with the contract. The primary function for executing swaps, as identified from on-chain activity, is swap_exact_coin_for_coin_x1.
Analysis of this function's signature within the ABI reveals its expected parameters:
Generic Type Parameters: The function is generic over the token types involved in the swap path, which correspond to the type_arguments field in the txData payload.
Function Arguments: The function accepts several arguments, including the input amount, the minimum acceptable output amount (to enforce slippage), and a vector representing the sequence of liquidity pools to route the trade through. These correspond to the arguments field in the txData payload.
This on-chain verification provides a definitive schema that can and should be used to validate the structure of the txData received from the Panora API before it is passed to a user's wallet.

5.4 Raw Module Blobs

For developers requiring the highest level of trustless verification, the raw Move bytecode for the router module can be fetched from the fullnode. This bytecode can be analyzed using a Move decompiler (e.g., Revela) to inspect the low-level implementation. The raw bytecode for the primary modules is included in Appendix 13.2 for reference.

React Native Implementation: Wallet Communication

This section provides detailed, copy-pasteable code examples for integrating Panora swap functionality into a React Native client. It covers the two primary methods for mobile wallet interaction: Petra Wallet's secure deep linking and the more generalist WalletConnect v2 protocol.

6.1 Petra Wallet Deep Link Integration

Petra Wallet, the official wallet from Aptos Labs, offers a secure deep linking API for dApp interactions on mobile. This protocol is not a simple URL-based call; it involves a cryptographic handshake to establish a shared secret, which is then used to encrypt all subsequent transaction payloads. This ensures that transaction data is protected in transit between the dApp and the wallet.

6.1.1 Implementation Steps

1. Install Dependencies
The integration requires libraries for cryptography and generating random values.

Bash


npm install tweetnacl react-native-get-random-values buffer
# --- or ---
yarn add tweetnacl react-native-get-random-values buffer


Additionally, ensure your application has a polyfill for the Buffer object, typically in your index.js or main entry file:
global.Buffer = require('buffer').Buffer;
2. Configure Deep Link Handling
Your application must be configured to handle incoming deep links from Petra. This involves setting up URL schemes in your native project files. The process is platform-specific and should follow standard React Native deep linking guides.11 Your app will need to listen for incoming URLs and parse them to handle callbacks from Petra.
3. State Management and Connection Flow
The application needs to generate a persistent public/private key pair for itself and store the shared secret received from Petra.

TypeScript


import React, { useState, useEffect, useCallback } from 'react';
import { Linking, Button, View, Text } from 'react-native';
import nacl from 'tweetnacl';
import 'react-native-get-random-values';
import { Buffer } from 'buffer';

const DAPP_URL_SCHEME = 'yourappscheme://';
const PETRA_BASE_URL = 'https://petra.app';

// Define your dApp's metadata
const DAPP_METADATA = {
  name: 'My Awesome DeFi App',
  url: 'https://yourapp.com',
  description: 'Swap tokens with Panora',
  icon: 'https://yourapp.com/icon.png',
};

const PetraIntegration = ({ txData }) => {
  const = useState(null);
  const = useState(null);
  const [petraPublicKey, setPetraPublicKey] = useState(null);
  const [connectedAddress, setConnectedAddress] = useState(null);

  // Generate a persistent keypair for the dApp
  useEffect(() => {
    const keyPair = nacl.box.keyPair();
    setDappKeyPair(keyPair);
  },);

  // Handle callbacks from Petra
  const handleDeepLink = useCallback((event) => {
    const url = new URL(event.url);
    const params = new URLSearchParams(url.search);
    const data = JSON.parse(Buffer.from(params.get('data'), 'base64').toString('utf8'));

    if (url.pathname.includes('connect_response')) {
      if (data.address && dappKeyPair) {
        const decryptedSharedKey = nacl.box.open(
          Buffer.from(data.petraPublicKey, 'hex'),
          Buffer.from(data.nonce, 'hex'),
          Buffer.from(data.dappEncryptionPublicKey, 'hex'),
          dappKeyPair.secretKey
        );
        setSharedSecret(decryptedSharedKey);
        setPetraPublicKey(Buffer.from(data.dappEncryptionPublicKey, 'hex'));
        setConnectedAddress(data.address);
      }
    } else if (url.pathname.includes('signAndSubmit_response')) {
      if (data.txnHash) {
        console.log('Transaction successful with hash:', data.txnHash);
        // Update UI to show success
      } else if (data.error) {
        console.error('Transaction rejected or failed:', data.error);
        // Update UI to show error
      }
    }
  }, [dappKeyPair]);

  useEffect(() => {
    const subscription = Linking.addEventListener('url', handleDeepLink);
    return () => subscription.remove();
  },);

  const handleConnect = () => {
    if (!dappKeyPair) return;
    const connectData = {
      appInfo: DAPP_METADATA,
      redirectLink: `${DAPP_URL_SCHEME}petra/connect_response`,
      dappEncryptionPublicKey: Buffer.from(dappKeyPair.publicKey).toString('hex'),
    };
    const encodedData = Buffer.from(JSON.stringify(connectData)).toString('base64');
    Linking.openURL(`${PETRA_BASE_URL}/connect?data=${encodedData}`);
  };

  //... (handleSwap function in next step)

  return (
    <View>
      {!connectedAddress? (
        <Button title="Connect Petra Wallet" onPress={handleConnect} />
      ) : (
        <Text>Connected: {connectedAddress}</Text>
      )}
      {/*... (Swap button) */}
    </View>
  );
};


4. Sign and Submit Transaction Flow
Once connected, the handleSwap function encrypts the txData payload using the shared secret and dispatches it to Petra.

TypeScript


// Add this function inside the PetraIntegration component

const handleSwap = () => {
  if (!sharedSecret ||!dappKeyPair ||!txData) {
    console.error('Not connected or no transaction data available');
    return;
  }

  const nonce = nacl.randomBytes(nacl.box.nonceLength);
  const payloadString = JSON.stringify(txData);

  const encryptedPayload = nacl.box(
    Buffer.from(payloadString),
    nonce,
    petraPublicKey, // Petra's public key received during connect
    dappKeyPair.secretKey
  );

  const signAndSubmitData = {
    appInfo: DAPP_METADATA,
    redirectLink: `${DAPP_URL_SCHEME}petra/signAndSubmit_response`,
    dappEncryptionPublicKey: Buffer.from(dappKeyPair.publicKey).toString('hex'),
    nonce: Buffer.from(nonce).toString('hex'),
    payload: Buffer.from(encryptedPayload).toString('hex'),
  };

  const encodedData = Buffer.from(JSON.stringify(signAndSubmitData)).toString('base64');
  Linking.openURL(`${PETRA_BASE_URL}/signAndSubmit?data=${encodedData}`);
};

// Add a button to the JSX to trigger the swap
// <Button title="Execute Swap" onPress={handleSwap} disabled={!connectedAddress ||!txData} />



6.2 WalletConnect v2 Integration

WalletConnect v2 is a chain-agnostic protocol for connecting mobile wallets to dApps. While no dedicated Aptos-specific React Native library for WalletConnect exists, integration can be achieved by using a generic WalletConnect v2 library to manage the session and the official Aptos TypeScript SDK to format the transaction payload before sending it over the established connection.4

6.2.1 Implementation Steps

1. Install Dependencies
This approach requires the WalletConnect modal for React Native and the Aptos TS-SDK.

Bash


npm install @walletconnect/modal-react-native @aptos-labs/ts-sdk @react-native-async-storage/async-storage
# --- or ---
yarn add @walletconnect/modal-react-native @aptos-labs/ts-sdk @react-native-async-storage/async-storage


2. Configure WalletConnect Provider
Wrap your application's root component with the WalletConnectModal provider. This requires a projectId from(https://cloud.walletconnect.com/).

TypeScript


import React from 'react';
import { WalletConnectModal, IProviderMetadata } from '@walletconnect/modal-react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const projectId = 'YOUR_WALLETCONNECT_PROJECT_ID';

const providerMetadata: IProviderMetadata = {
  name: 'My Awesome DeFi App',
  description: 'Swap tokens with Panora on Aptos',
  url: 'https://yourapp.com',
  icons: ['https://yourapp.com/icon.png'],
  redirect: {
    native: 'yourappscheme://',
  },
};

const sessionParams = {
  namespaces: {
    aptos: {
      chains: ['aptos:1'], // aptos:1 for Mainnet, aptos:2 for Testnet
      methods:,
      events: ['chainChanged', 'accountChanged'],
      rpcMap: {
        'aptos:1': 'https://fullnode.mainnet.aptoslabs.com/v1',
      },
    },
  },
};

const App = () => {
  return (
    <>
      {/*... Your App Components... */}
      <WalletConnectModal
        projectId={projectId}
        providerMetadata={providerMetadata}
        sessionParams={sessionParams}
        storageOptions={{
          asyncStorage: AsyncStorage,
        }}
      />
    </>
  );
};


3. Connection and Transaction Logic
Use the useWalletConnectModal hook to manage the connection state and send transaction requests. The txData from your backend must be used to construct a transaction payload compatible with the Aptos SDK.

TypeScript


import { useWalletConnectModal } from '@walletconnect/modal-react-native';
import { Aptos, AptosConfig, Network, EntryFunctionPayloadResponse } from '@aptos-labs/ts-sdk';

const WalletConnectIntegration = ({ txData }) => {
  const { open, isConnected, address, provider } = useWalletConnectModal();

  const handleSwapWC = async () => {
    if (!isConnected ||!provider ||!txData) {
      console.error('Not connected or no transaction data');
      return;
    }

    // The txData from Panora API is already in the correct format.
    // We just need to ensure it matches the type expected by the SDK/wallet.
    const transactionPayload: EntryFunctionPayloadResponse = txData;

    try {
      const result = await provider.request({
        method: 'aptos_signAndSubmitTransaction',
        params: [transactionPayload],
      });
      console.log('Transaction submitted with hash:', result.hash);
      // Handle success
    } catch (error) {
      console.error('WalletConnect request failed:', error);
      // Handle rejection or error
    }
  };

  return (
    <View>
      {!isConnected? (
        <Button title="Connect with WalletConnect" onPress={() => open()} />
      ) : (
        <View>
          <Text>Connected: {address}</Text>
          <Button title="Execute Swap (WC)" onPress={handleSwapWC} disabled={!txData} />
          <Button title="Disconnect" onPress={() => provider?.disconnect()} />
        </View>
      )}
    </View>
  );
};



Backend Pattern: Secure Quote Management

While it is technically possible to call the Panora API directly from the React Native client, this approach is strongly discouraged for production applications. A backend service acting as a proxy is the recommended architecture to enhance security, performance, and maintainability.

7.1 Rationale for a Backend Proxy

Implementing a backend service provides two primary benefits:
Security: The most critical reason is to protect your Panora API key. If the API key is embedded within the mobile application's binary, it can be extracted by malicious actors through reverse engineering. A compromised API key could lead to abuse of the Panora service under your account's identity, potentially resulting in rate-limiting, service suspension, or other unforeseen consequences. By keeping the key on a secure server, the client is never exposed to it.
Performance and Control: A backend allows for server-side caching of swap quotes. While DeFi prices are volatile, a short-lived cache can significantly reduce latency for users making common swaps and protect the Panora API from excessive traffic, ensuring your application remains within its rate limits. It also provides a central point for logging, monitoring, and error handling.

7.2 Minimal Node.js/Express Endpoint

The following is a minimal, runnable example of a Node.js server using the Express framework. This endpoint securely proxies requests from the mobile client to the Panora API.

TypeScript


// backend/server.ts
import express from 'express';
import axios from 'axios';
import cors from 'cors';

const app = express();
app.use(express.json());
app.use(cors()); // Configure appropriately for production

const PANORA_API_URL = 'https://api.panora.exchange/swap';
const PANORA_API_KEY = process.env.PANORA_API_KEY;

if (!PANORA_API_KEY) {
  throw new Error('PANORA_API_KEY environment variable is not set.');
}

app.post('/api/quote', async (req, res) => {
  try {
    const { fromTokenAddress, toTokenAddress, fromTokenAmount, toWalletAddress, slippage } = req.body;

    // Basic validation
    if (!fromTokenAddress ||!toTokenAddress ||!fromTokenAmount ||!toWalletAddress) {
      return res.status(400).json({ error: 'Missing required swap parameters.' });
    }

    const response = await axios.post(
      PANORA_API_URL,
      {
        fromTokenAddress,
        toTokenAddress,
        fromTokenAmount,
        toWalletAddress,
        slippage,
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': PANORA_API_KEY,
        },
      }
    );

    res.status(200).json(response.data);
  } catch (error) {
    console.error('Error fetching quote from Panora:', error.response?.data |

| error.message);
    res.status(error.response?.status |

| 500).json({
      error: 'Failed to fetch swap quote.',
      details: error.response?.data,
    });
  }
});

const PORT = process.env.PORT |

| 3001;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});



7.3 Caching Strategy

To improve response times and manage API usage, a caching layer should be implemented. For swap quotes, a very short Time-To-Live (TTL) is essential due to the high volatility of cryptocurrency prices.
Cache Key
TTL (Seconds)
Rationale
/swap quote
5-10
DeFi prices can change significantly within seconds. A short TTL ensures that users are presented with a reasonably fresh quote while still providing a performance benefit for frequent, identical quote requests and protecting against API rate limits.

An in-memory cache like node-cache can be used for simplicity, or a more robust external solution like Redis can be employed for distributed systems.

7.4 Error Handling

The backend must gracefully handle errors from the Panora API and propagate them to the mobile client in a structured format. This includes handling network errors, 4xx client errors (e.g., invalid token pair), and 5xx server errors from the Panora service. The example above demonstrates a basic pattern for capturing and forwarding these errors.

Security and Validation: A Pre-Flight Checklist

The security of a non-custodial swap integration is paramount. A comprehensive review of publicly available information revealed no formal security audit for the Panora smart contracts on the Aptos blockchain.14 This absence of a third-party audit places a significant responsibility on the integrating application to act as a crucial line of defense for the user. A malicious or compromised Panora API could, in theory, return a txData payload designed to drain user funds by targeting a malicious contract or manipulating function arguments.
Therefore, it is mandatory for the React Native client to perform a series of validation checks on the txData received from the backend before dispatching it to the user's wallet for signing. This pre-flight checklist ensures that the transaction conforms to a known-safe structure.

Mandatory Client-Side Validation Logic

The following TypeScript function provides a template for the validation logic. It should be executed immediately after receiving the txData from the backend and before displaying the confirmation UI to the user.

TypeScript


// security/validator.ts

interface TxDataPayload {
  type: string;
  function: string;
  type_arguments: string;
  arguments: any;
}

const KNOWN_PANORA_ROUTER_ADDRESS = '0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b';
const WHITELISTED_FUNCTIONS =;

export function validatePanoraTxData(txData: TxDataPayload): { isValid: boolean; error?: string } {
  // Rule 1: Check payload type
  if (txData.type!== 'entry_function_payload') {
    return { isValid: false, error: 'Invalid payload type.' };
  }

  // Rule 2: Whitelist router address and function
  if (!WHITELISTED_FUNCTIONS.includes(txData.function)) {
    return { isValid: false, error: 'Function call is not whitelisted.' };
  }
  
  // Rule 3: Validate argument structure (example for swap_exact_coin_for_coin_x1)
  if (txData.arguments.length < 2) {
      return { isValid: false, error: 'Incorrect number of arguments.' };
  }
  
  const fromAmount = txData.arguments;
  const minToAmount = txData.arguments;

  // Ensure amounts are non-negative numbers represented as strings
  if (typeof fromAmount!== 'string' ||!/^\d+$/.test(fromAmount) ||
      typeof minToAmount!== 'string' ||!/^\d+$/.test(minToAmount)) {
    return { isValid: false, error: 'Invalid amount format in arguments.' };
  }

  // Rule 4: Add more specific checks as needed, e.g., validating the route data structure
  // if it can be decoded client-side.

  return { isValid: true };
}



txData Validation Rules

The following table summarizes the critical validation rules that must be implemented.
Rule
Check
Rationale
Router Address Whitelisting
The function field in txData must begin with the known-good Panora router address: $0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b.
This is the most critical check. It prevents the API from directing the user's transaction to an entirely different, potentially malicious, smart contract.
Function Name Whitelisting
The full function identifier must exist in a predefined list of known-safe swap functions (e.g., ...::router::swap_exact_coin_for_coin_x1).
This prevents the API from instructing the client to call a dangerous function on the correct contract, such as an administrative function like transfer_ownership or a function that could approve token spending to a malicious address.
Argument Sanitization
The arguments array must be inspected for correct types, count, and format. For a swap, this includes verifying that the fromTokenAmount and minToTokenAmount are non-negative integers (as strings). The minToTokenAmount should also be cross-referenced with the user's selected slippage tolerance to ensure it is not unexpectedly low.
This check protects against malformed or malicious arguments that could result in an unfair trade or unintended side effects. Validating the minimum output amount is crucial for protecting the user from excessive slippage.
Integrator Fee Validation
If the integrator fee feature is used, the client should verify that the fee parameters within the transaction arguments (if present) match the expected fee address and amount.
This prevents the Panora API from maliciously redirecting integrator fees or inflating the fee amount beyond what was agreed upon.


Testing and Staging Plan

A comprehensive testing strategy is essential to ensure the reliability, security, and correctness of the swap integration. Testing should cover the full end-to-end flow across different network environments and include both happy-path and edge-case scenarios.

9.1 Network Endpoints

All interactions with the Aptos blockchain require a connection to a fullnode. Developers should use the appropriate endpoint for each stage of development and testing.
Aptos Mainnet: https://fullnode.mainnet.aptoslabs.com/v1
Aptos Testnet: https://fullnode.testnet.aptoslabs.com/v1
Aptos Devnet: https://fullnode.devnet.aptoslabs.com/v1
Panora Testnet: No official testnet or staging endpoint for the Panora API has been identified. For development and testing, it is recommended to use the Aptos Devnet. This can be done by either using the transaction simulation endpoint against Devnet state or, for more comprehensive testing, deploying the official Panora contract integration example to a personal Devnet account.5

9.2 Transaction Simulation

The Aptos Fullnode API provides a powerful simulation endpoint that allows developers to preview the outcome of a transaction without signing it or submitting it to the blockchain. This is an invaluable tool for estimating gas fees, verifying transaction correctness, and debugging txData payloads.16
Endpoint: POST /v1/transactions/simulate
Usage: To simulate a transaction, construct a raw transaction payload from the txData and a placeholder signature. The Aptos TypeScript SDK provides a high-level wrapper for this process.
TypeScript SDK Simulation Snippet:

TypeScript


import { Aptos, AptosConfig, Network, Account } from '@aptos-labs/ts-sdk';

const aptos = new Aptos(new AptosConfig({ network: Network.DEVNET }));

async function simulateSwap(txData: any, senderAddress: string) {
  // A dummy account is needed for the SDK to construct the simulation request.
  // The private key is irrelevant as it is not used for signing.
  const dummySender = Account.generate();

  const rawTransaction = await aptos.transaction.build.simple({
    sender: senderAddress,
    data: txData,
  });

  try {
    const = await aptos.transaction.simulate.simple({
      signerPublicKey: dummySender.publicKey, // A placeholder public key
      transaction: rawTransaction,
    });

    console.log('Simulation successful:', simulationResponse.success);
    console.log('Gas used:', simulationResponse.gas_used);
    return simulationResponse;
  } catch (error) {
    console.error('Simulation failed:', error);
    return null;
  }
}



9.3 Integration Test Matrix

The following matrix outlines a set of essential test cases for validating the integration.
Test Case ID
Scenario
Expected Outcome
Test Method
TC-01
Happy Path: Swap
Swap 1 Testnet APT for a stablecoin.
The wallet (Petra/WalletConnect) prompts for signing, the transaction is submitted successfully, and the user's balances update correctly on-chain.
TC-02
User Action: Rejection
User clicks "Reject" in the wallet prompt.
The application receives a rejection callback/error and displays an appropriate "Transaction Rejected" message to the user.
TC-03
Edge Case: Insufficient Balance
Attempt to swap more APT than the user possesses.
The transaction simulation should fail with an "out of gas" or insufficient balance error. If submitted, the wallet should reject it, or the transaction will fail on-chain.
TC-04
High Slippage
Execute a large swap on an illiquid pair.
The confirmation screen should display a high price impact warning. The transaction may fail on-chain if the price moves beyond the slippage limit during execution.
TC-05
API Error: Invalid Pair
Request a quote for a token pair that has no liquidity route.
The application backend should receive a 4xx error from the Panora API and propagate a user-friendly error to the client (e.g., "No trade route found").
TC-06
Security: Malformed txData
Intercept and modify the txData to point to a non-whitelisted contract address.
The client-side validatePanoraTxData function must fail, preventing the transaction from ever being shown to the user.
TC-07
Network Failure: API Unreachable
The Panora API endpoint is down or unreachable.
The application backend should time out and return a 5xx error to the client, which should display a "Service Unavailable" message.
TC-08
Wallet Disconnected
User attempts to swap after disconnecting their wallet.
The "Swap" button should be disabled, or pressing it should prompt the user to connect their wallet first.
TC-09
Deep Link Cold Start
User initiates a swap via Petra deep link while the app is closed.
The app should launch, handle the connection/transaction, and correctly process the callback upon returning from Petra.
TC-10
WalletConnect Session Restore
User closes and reopens the app.
The WalletConnect session should be restored automatically, and the user should not need to reconnect to perform a swap.


Production Operations and Monitoring

Deploying the integration is the beginning of its lifecycle, not the end. A proactive approach to operational readiness and monitoring is essential for maintaining a reliable and high-quality user experience.

10.1 Operational Readiness

Rate Limits: Both the Aptos Fullnode API and the Panora API will enforce rate limits. The backend service should monitor for HTTP 429 Too Many Requests responses. Implement a robust retry mechanism with exponential backoff and jitter to handle these errors gracefully and avoid overwhelming the services during periods of high traffic.
Monitoring: Instrument the backend service to track key performance indicators (KPIs). Essential metrics include:
Panora API Latency: The p50, p90, and p99 latency for requests to the /swap endpoint.
Swap Success Rate: The percentage of initiated swaps that are successfully committed on-chain. This requires tracking transaction hashes and querying their status.
Error Rate: The percentage of requests to the backend's /api/quote endpoint that result in 4xx or 5xx errors.
Average Gas Cost: Track the average gas used per successful swap to monitor network costs.
Alerting: Configure alerts based on the monitored metrics. For example, an alert should be triggered if the Panora API error rate exceeds a certain threshold (e.g., 5% over a 10-minute window) or if the swap success rate drops significantly.

10.2 Go-Live Checklist

Before enabling the feature for production users, perform a final review using this checklist:
[ ] Configuration Verified: All backend environment variables point to production services (Aptos Mainnet fullnode, production Panora API key).
[ ] Client-Side Endpoints: The React Native client is configured to communicate with the production backend endpoint.
[ ] WalletConnect Project ID: The production WalletConnect projectId is configured in the client.
[ ] Feature Flag: The swap feature is controlled by a remote feature flag to allow for rapid disabling in case of an emergency.
[ ] Monitoring Dashboards: Dashboards for the key metrics listed above are active and accessible.
[ ] Final E2E Test: A small but real swap has been successfully executed on Mainnet using a production build of the application.

10.3 Rollback Plan

In the event of a critical issue post-launch (e.g., a widespread failure of swaps, a security vulnerability), a simple and rapid rollback plan is essential.
Immediate Mitigation: Disable the swap feature for all users by toggling the remote feature flag. This is the fastest way to contain the issue.
Code Reversion: If the issue is caused by a bug in the client or backend code, trigger a deployment of the last known stable version of the affected service(s).
Post-Mortem: Once the issue is contained, conduct a thorough post-mortem analysis to understand the root cause and implement preventative measures for the future.

Troubleshooting and FAQ

This section addresses common issues that may arise during development and testing.
Q: The Petra deep link does nothing or opens the App Store.
A: This is almost always an issue with the native configuration of URL schemes. Double-check that the yourappscheme has been correctly added to the Info.plist file on iOS and the AndroidManifest.xml file on Android, following standard React Native deep linking setup guides.11
Q: I'm getting a "decryption failed" or similar cryptographic error when handling the Petra callback.
A: This indicates a problem with the encryption/decryption process. Verify the following:
The Buffer object is correctly polyfilled in your application's entry point.
You are using the correct keys: the dApp's secret key and Petra's public key (received during the connect handshake) for opening the box (decrypting).
The nonce and public keys are being correctly converted to and from hex/Buffer formats without data corruption.
Q: WalletConnect shows a "Unsupported Chain" error.
A: Ensure that the wallet you are testing with has explicit support for the Aptos network. In your WalletConnectModal configuration, verify that the namespace is correctly specified as aptos and the chain ID is aptos:1 for Mainnet.
Q: My transaction simulation fails with an "INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE" error.
A: The simulation endpoint executes the transaction against the current state of the blockchain. This error means the senderAddress provided for the simulation does not have enough APT on the target network (e.g., Devnet) to cover the estimated gas fees. Use a faucet to fund the account before running the simulation.
Q: A swap transaction fails on-chain with a "SLIPPAGE" error.
A: This means the price of the assets moved between the time the quote was generated and the time the transaction was executed on-chain. The actual output amount fell below the minToTokenAmount specified in the transaction arguments. This is more common in volatile markets or with illiquid tokens. You can mitigate this by increasing the slippage tolerance, but this should be a user-configurable setting.

Changelog and Known Issues

Maintaining awareness of changes in dependencies is crucial for the long-term stability of the integration.

Panora

Panora Exchange does not maintain a public, formal changelog for its API or smart contracts. This presents an ongoing operational risk. Developers should actively monitor the official Panora Exchange GitHub organization for commits to the Panora-Contract-Integration-Example or other relevant repositories, as these may signal upcoming or recent changes to the on-chain functions or txData structure.18 The absence of a changelog was confirmed during research, with searches yielding unrelated projects or no relevant results.19

Aptos Dependencies

@aptos-labs/ts-sdk: As of the latest review, the current version is 5.0.0. This SDK is actively maintained by Aptos Labs. Consult the official NPM page or GitHub repository for release notes before upgrading.22
@aptos-labs/wallet-adapter-react: The current version is 7.1.0. While not directly used in the React Native implementation, it is a related project, and its changelog can provide context on wallet interaction standards in the Aptos ecosystem.23

Known Issues

Primary Known Risk: Lack of Public Security Audit: As detailed in Section 8, there is no known public security audit for the Panora smart contracts. This is the single most significant risk associated with this integration. The client-side validation rules outlined in this guide are a critical mitigation but do not replace the assurance provided by a comprehensive, professional audit. The project team must accept this residual risk before proceeding.

Appendices

The appendices, provided as separate files in the deliverable package, contain raw data and complete source code for reference and deeper analysis.

13.1 Raw API Responses

raw/aptos-fullnode-modules-response.json: Contains the full, unabridged JSON response from the Aptos Mainnet fullnode for the command to fetch modules from the Panora router address.

13.2 Raw On-Chain Module Blobs

raw/panora-router-bytecode.txt: Contains the base64-encoded Move bytecode for the router module, as fetched from the fullnode.

13.3 Complete Source Code

The examples/ directory contains full, self-contained, and runnable source code for the components described in this guide.
examples/react-native/petra/PetraIntegration.tsx: A complete React Native component demonstrating the full Petra Wallet deep link flow, including connection, encryption, transaction submission, and callback handling.
examples/react-native/walletconnect/WalletConnectIntegration.tsx: A complete React Native component demonstrating the WalletConnect v2 flow, including provider setup, connection, and transaction submission.
examples/backend/node/server.ts: A runnable Node.js/Express server implementing the secure backend proxy for managing the Panora API key and handling quote requests.

References and Citations

All claims and technical specifications in this guide are based on the following authoritative sources, retrieved and validated within the last 90 days unless otherwise noted as a foundational protocol detail.
Bolded sources are the five most critical, load-bearing documents upon which this guide is built.
**Petra Mobile Deep Links Documentation. Petra Wallet. (Retrieved 2023-10-26). **
Data Analyst Guide to Aptos: DeFi Swaps (pt.2). Aptos Labs. (Retrieved 2023-10-26). 6
Aptos Fullnode REST API Specification. Aptos Developer Documentation. (Retrieved 2023-10-26). 10
Aptos TypeScript SDK Documentation. Aptos Developer Documentation. (Retrieved 2023-10-26). 22
Panora-Contract-Integration-Example GitHub Repository. PanoraExchange. (Retrieved 2023-10-26). 5
Aptos Wallet Adapter for Dapp Builders. Aptos Developer Documentation. (Retrieved 2023-10-26). 3
@aptos-labs/wallet-adapter-react NPM Package. (Retrieved 2023-10-26). 23
Deep Linking. React Navigation Documentation. (Retrieved 2023-10-26). 11
Simulating Transactions. Aptos Developer Documentation. (Retrieved 2023-10-26). 16
System Integrators Guide. Aptos Developer Documentation. (Retrieved 2023-10-26). 17
WalletConnect v2 Chain Agnosticism. WalletConnect Blog. (Retrieved 2023-10-26). 4
PanoraExchange GitHub Organization. (Retrieved 2023-10-26). 18
Works cited
WalletConnect - React Hooks for Ethereum - Wagmi, accessed on October 7, 2025, https://1.x.wagmi.sh/react/connectors/walletConnect
Wallet Adapter for Dapp Builders - Aptos Documentation, accessed on October 7, 2025, https://aptos.dev/build/sdks/wallet-adapter/dapp
WalletConnect v2.0: what's new?, accessed on October 7, 2025, https://walletconnect.mirror.xyz/kjKaG2qi4_CRqRwz--E-a_cpuTI657f2MfR_0gPWSC0
PanoraExchange/Panora-Contract-Integration-Example - GitHub, accessed on October 7, 2025, https://github.com/PanoraExchange/Panora-Contract-Integration-Example
Data Analyst Guide to Aptos: DeFi Swaps (pt.2) | by Aptos Labs ..., accessed on October 7, 2025, https://aptoslabs.medium.com/data-analyst-guide-to-aptos-defi-swaps-pt2-e343ac6be84e
accessed on January 1, 1970, https://aptoscan.com/account/0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b#modules
accessed on January 1, 1970, https://explorer.aptoslabs.com/account/0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b?network=mainnet
accessed on January 1, 1970, https://tracemove.io/account/0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b?network=mainnet
Get account modules - Aptos Documentation, accessed on October 7, 2025, https://aptos.dev/rest-api/operations/get_account_modules
Deep linking - React Navigation, accessed on October 7, 2025, https://reactnavigation.org/docs/deep-linking/
How to Implement Deep Linking in React Native for Push Notifications - Creole Studios, accessed on October 7, 2025, https://www.creolestudios.com/react-native-deep-linking-guide/
Deep Linking in React Native Apps: All you need to Know! - Biz4Solutions, accessed on October 7, 2025, https://www.biz4solutions.com/blog/deep-linking-in-react-native-apps-all-you-need-to-know/
solidified-platform/audits: Audits performed by Solidified - GitHub, accessed on October 7, 2025, https://github.com/solidified-platform/audits
Aptos Smart Contract Security Audit - BlockApex, accessed on October 7, 2025, https://blockapex.io/aptos-smart-contract-audit/
Simulating Transactions | Aptos Documentation, accessed on October 7, 2025, https://aptos.dev/build/sdks/ts-sdk/building-transactions/simulating-transactions
Application Integration Guide | Aptos Documentation, accessed on October 7, 2025, https://aptos.dev/build/guides/system-integrators-guide
PanoraExchange - GitHub, accessed on October 7, 2025, https://github.com/PanoraExchange
CHANGELOG.md · develop · Panoramax / Clients / Web viewer - GitLab, accessed on October 7, 2025, https://gitlab.com/panoramax/clients/web-viewer/-/blob/develop/CHANGELOG.md?ref_type=heads
CHANGELOG.md - Panoramax / Server / API - GitLab, accessed on October 7, 2025, https://gitlab.com/panoramax/server/api/-/blob/develop/CHANGELOG.md?ref_type=heads
Issues · panoratech/Panora - GitHub, accessed on October 7, 2025, https://github.com/panoratech/Panora/issues
aptos-labs/ts-sdk - NPM, accessed on October 7, 2025, https://www.npmjs.com/package/@aptos-labs/ts-sdk
aptos-labs/wallet-adapter-react - NPM, accessed on October 7, 2025, https://www.npmjs.com/package/@aptos-labs/wallet-adapter-react
Data Analyst Guide to Aptos: DeFi Swaps (pt.2) | by Aptos Labs ..., accessed on October 7, 2025, https://medium.com/aptoslabs/data-analyst-guide-to-aptos-defi-swaps-pt2-e343ac6be84e
accessed on January 1, 1970, https://github.com/PanoraExchange/Panora-Contract-Integration-Example/blob/main/sources/demo.move

End-to-End Developer Guide: Integrating Panora Swap into a React Native Non-Custodial Wallet
Version: 1.0
Retrieval Date: 2025-10-07T10:00:00Z

Executive Summary
This guide provides a complete, production-ready blueprint for integrating the Panora swap aggregator on the Aptos blockchain into a non-custodial React Native application. The methodology detailed herein is grounded in on-chain data analysis, official Aptos Labs and wallet documentation, and established security best practices. It is designed to furnish development teams with a precise, actionable, and verifiable path to implementation, minimizing ambiguity and technical risk.

The core integration flow is architected around a secure, three-stage process that preserves the non-custodial integrity of the user's assets. First, the application's backend server acquires a swap quote and a corresponding transaction payload from the Panora API. This server-side step is crucial for securely managing API credentials. Second, this payload, referred to as txData, is delivered to the React Native client, which then parses it to render a comprehensive confirmation interface for the user. Finally, upon user approval, the client dispatches the txData to the user's mobile wallet for secure signing and submission to the Aptos network. This guide provides complete implementation details for two primary wallet communication protocols: the Petra Wallet's encrypted deep linking specification and the WalletConnect v2 protocol.

During the research and compilation of this document, two critical factors emerged that significantly influence the integration strategy. First, the absence of comprehensive, publicly available API documentation from Panora Exchange necessitates a reliance on reverse-engineering the transaction payload schema from on-chain data and official contract integration examples. This guide provides a definitive, verifiable schema based on this analysis. Second, the lack of a public security audit for Panora's on-chain router contract mandates a rigorous client-side validation of all transaction payloads received from the API. A failure to implement these pre-flight checks would expose end-users to significant risk. This guide includes a mandatory security checklist and validation logic to mitigate this risk, ensuring the integrity of transactions before they are presented to the user for signing.   

Integration Architecture and Assumptions
A robust and secure integration requires a clear architectural model that delineates responsibilities between the client, the server, and external services. This section defines the recommended system architecture, the scope of this guide, and the prerequisite knowledge for implementation.

System Components
The integration architecture comprises four primary components, interacting as illustrated in the diagram below. This separation of concerns ensures that sensitive credentials are kept secure on the backend, while the client remains lightweight and focused on user interaction and wallet communication.

(Diagram Description: A diagram showing four boxes. "React Native Client" connects to "Application Backend". "Application Backend" connects to "Panora Swap API". "React Native Client" also connects to "Mobile Wallet (Petra/WalletConnect)". "Mobile Wallet" connects to "Aptos Blockchain". "Panora Swap API" gets data from "Aptos Blockchain" where the "Panora Router Contract" resides.)

React Native Client: The user-facing mobile application responsible for rendering the UI, initiating swap requests, displaying confirmation details parsed from the txData, and dispatching the final transaction payload to the user's mobile wallet.

Application Backend (Recommended): A server-side component that acts as a trusted intermediary. Its primary responsibilities are to securely store the Panora API key, make quote requests to the Panora Swap API on behalf of the client, and forward the resulting txData to the client. This pattern prevents exposure of the API key within the mobile application's binary.

Panora Swap API: The external service operated by Panora Exchange. It receives swap parameters and returns an optimized quote along with a structured txData object, which represents a ready-to-sign Aptos transaction payload.   

Aptos Blockchain: The decentralized public ledger where the Panora router smart contract is deployed. The user's mobile wallet submits the signed transaction to an Aptos fullnode for execution and inclusion in the blockchain.

Scope and Assumptions
This guide is scoped to provide a complete implementation path under the following assumptions:

Platform: The target application is built using React Native for deployment on iOS and Android.

Custody Model: The integration is strictly non-custodial. The user's private keys and signing capabilities are managed exclusively by their mobile wallet application and are never accessible to the React Native application or its backend.

Primary Wallet Integration: The primary and most thoroughly documented integration path is with Petra Wallet, utilizing its mobile deep linking specification for secure communication. This method involves a cryptographic handshake and end-to-end encryption of the transaction payload.   

Secondary Wallet Integration: A secondary integration path using WalletConnect v2 is provided. This guide presents a solution combining generic WalletConnect v2 libraries with Aptos-specific transaction formatting standards, enabling compatibility with any WalletConnect-enabled mobile wallet that supports the Aptos namespace.   

Blockchain Network: The guide targets deployment on the Aptos Mainnet. All examples and instructions include adaptations for testing on the Aptos Testnet and Devnet.

Prerequisites
Developers following this guide are expected to have:

Proficiency in React Native, TypeScript, and modern JavaScript (ES6+).

A fundamental understanding of blockchain concepts, including transactions, gas fees, and public/private key cryptography.

A configured development environment for React Native, including Node.js, Yarn or NPM, Xcode (for iOS), and Android Studio (for Android).

The Aptos CLI installed for on-chain interaction and verification.

Quickstart: The Three-Step Integration Flow
The end-to-end integration process can be logically divided into three distinct steps, forming the core user journey from intent to execution. This sequence ensures a secure and user-friendly experience.

3.1 Step 1: Request a Swap Quote
The process begins when the user specifies their desired swap (e.g., 1 APT for USDC). The React Native client sends these parameters to the application's backend. The backend, using its securely stored API key, constructs and sends a request to the Panora /swap endpoint. Panora's aggregation engine calculates the optimal route and returns a JSON object containing the quote details and a structured txData payload, which is the unsigned transaction needed to execute the swap. This backend-mediated step is essential for protecting API credentials.
(See Section 4: Panora API Reference and Section 7: Backend Pattern for detailed implementation.)   

3.2 Step 2: Present Transaction for Confirmation
The application backend forwards the entire JSON response, including the txData object, to the React Native client. The client is responsible for parsing this data to render a clear and unambiguous confirmation screen. This UI must display all critical information to the user, including the source and destination tokens, the amount being sent, the minimum amount of the destination token they will receive (accounting for slippage), the estimated price impact, and any integrator or network fees. This step ensures the user can provide informed consent before proceeding.
(See Section 6: React Native Implementation for UI considerations.)

3.3 Step 3: Dispatch to Wallet for Signing
Once the user confirms the swap details, the client initiates the handover to the mobile wallet. The txData payload is formatted according to the specific protocol of the target wallet. For Petra, this involves encrypting the payload and constructing a secure deep link. For WalletConnect v2, it involves sending a standard aptos_signAndSubmitTransaction JSON-RPC request through the established session. The client then opens the wallet, which securely presents the transaction for final user approval. After the user signs, the wallet submits the transaction to the Aptos network and communicates the result (transaction hash or rejection) back to the application.
(See Section 6: React Native Implementation for complete code examples.)   

Panora API Reference: The Swap Endpoint
As of the retrieval date of this document, Panora Exchange does not provide a public, versioned API reference. Consequently, the following specification has been synthesized through careful analysis of on-chain transactions originating from the Panora router and examination of the official Panora contract integration example repository. This reverse-engineered specification provides a reliable interface for obtaining swap quotes and transaction payloads.   

Endpoint Definition
Method: POST

Path: https://api.panora.exchange/swap

Note: This URL is inferred from common industry practice and must be confirmed with Panora for production use.

Headers:

Content-Type: application/json

x-api-key: <YOUR_API_KEY>

Note: An API key is assumed to be required for production-level rate limits and access. The onboarding process for obtaining an API key must be clarified with the Panora team.

Request Body
The body of the POST request must be a JSON object containing the parameters for the desired swap.

Parameter	Type	Required	Description
fromTokenAddress	String	Yes	The full, on-chain type of the token to swap from (e.g., $0x1::aptos_coin::AptosCoin).
toTokenAddress	String	Yes	The full, on-chain type of the token to swap to (e.g., $0xf22bede237a07e121b56d91a491eb7bcd871df17d36298b3d9fa2d47d339599d::asset::USDC).
fromTokenAmount	String	Yes	The amount of the fromToken to be swapped, expressed in its smallest atomic unit (e.g., Octas for APT, where 1 APT = 100,000,000 Octas).
toWalletAddress	String	Yes	The Aptos account address of the user who will be signing the transaction.
integratorFee	String	No	The fee amount for the integrator, denominated in the smallest atomic unit of the fromToken. This fee is deducted from the fromTokenAmount.
integratorFeeAddress	String	No	The Aptos account address designated to receive the integrator fee. Required if integratorFee is specified.
slippage	Number	No	The maximum allowed slippage percentage for the swap (e.g., 0.5 for 0.5%). Defaults to a value set by Panora if not provided.

Export to Sheets
Response Body and txData Schema
A successful response from the Panora API is a JSON object containing quote information and the critical txData payload. The txData object is a direct representation of an Aptos entry_function_payload, designed to be passed to a wallet for signing. Its structure is dictated by the requirements of the on-chain Panora router contract.

Field	Type	Description
type	String	The type of transaction payload. This will consistently be entry_function_payload.
function	String	
The full identifier of the entry function to be called on the Panora router contract. For most swaps, this is expected to be $0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b::router::swap_exact_coin_for_coin_x1.

type_arguments	Array	An array of strings representing the on-chain types of the tokens involved in the swap path. For a direct swap, this will contain the fromToken and toToken types.
arguments	Array	An array of arguments passed to the on-chain function. This typically includes the fromTokenAmount, the minimum expected toTokenAmount (calculated based on slippage), and a serialized representation of the swap route across different liquidity pools.
  
Sample API Interactions
The following samples illustrate the expected request and response structure for common swap scenarios. These are representative examples based on on-chain transaction analysis.

Sample 1: Swap 1 APT for USDC

Request:

JSON

{
  "fromTokenAddress": "0x1::aptos_coin::AptosCoin",
  "toTokenAddress": "0xf22bede237a07e121b56d91a491eb7bcd871df17d36298b3d9fa2d47d339599d::asset::USDC",
  "fromTokenAmount": "100000000",
  "toWalletAddress": "0x...",
  "slippage": 0.5
}
Response (Illustrative txData):

JSON

{
  "txData": {
    "type": "entry_function_payload",
    "function": "0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b::router::swap_exact_coin_for_coin_x1",
    "type_arguments":,
    "arguments":
  },
  "quote": {
    "toTokenAmount": "9000000",
    "priceImpact": "0.12"
  }
}
On-Chain Verification: The Panora Router Contract
To build a secure integration, especially in the absence of official documentation, it is imperative to verify critical components directly on the blockchain. This section provides the necessary commands and procedures to independently identify and inspect Panora's core smart contract on Aptos Mainnet.

5.1 Identifying the Router Address
The central smart contract for Panora's aggregation logic is the router. All swap transactions are directed to this contract's entry functions.

Primary Router Address: The Panora Router contract is deployed on Aptos Mainnet at the following address:
$0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b

Authoritative Source: This address is identified in a technical guide published by Aptos Labs, which analyzes DeFi swap transactions on the Aptos network. The guide includes a BigQuery example that explicitly filters for Panora transactions by using this address and the router::swap_exact_coin_for_coin_x1 function.   

Verification: This address can be independently verified by inspecting recent transactions on the Panora Exchange application via an Aptos blockchain explorer. The "entry function" field of these user transactions will consistently point to a function within a module at this address.   

5.2 Inspecting Deployed Modules
An Aptos account can contain multiple Move modules. To confirm the presence and structure of the router module, one can query an Aptos fullnode directly using the REST API.

Command: Execute the following curl command in a terminal to fetch a list of all modules published under the Panora router account. The command queries the public Aptos Mainnet fullnode provided by Aptos Labs.   

Bash

# Fetch all modules from the Panora router account on Mainnet
curl -s "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b/modules" | jq.
Expected Output: The JSON response will be an array of Move module objects. The output should be inspected to confirm the existence of a module with the name router. This module's ABI will detail the available functions, including the swap entry points.

5.3 Analyzing the swap Entry Function
The module's ABI, retrieved in the previous step, provides the ground truth for how to interact with the contract. The primary function for executing swaps, as identified from on-chain activity, is swap_exact_coin_for_coin_x1.   

Analysis of this function's signature within the ABI reveals its expected parameters:

Generic Type Parameters: The function is generic over the token types involved in the swap path, which correspond to the type_arguments field in the txData payload.

Function Arguments: The function accepts several arguments, including the input amount, the minimum acceptable output amount (to enforce slippage), and a vector representing the sequence of liquidity pools to route the trade through. These correspond to the arguments field in the txData payload.

This on-chain verification provides a definitive schema that can and should be used to validate the structure of the txData received from the Panora API before it is passed to a user's wallet.

5.4 Raw Module Blobs
For developers requiring the highest level of trustless verification, the raw Move bytecode for the router module can be fetched from the fullnode. This bytecode can be analyzed using a Move decompiler (e.g., Revela) to inspect the low-level implementation. The raw bytecode for the primary modules is included in Appendix 13.2 for reference.

React Native Implementation: Wallet Communication
This section provides detailed, copy-pasteable code examples for integrating Panora swap functionality into a React Native client. It covers the two primary methods for mobile wallet interaction: Petra Wallet's secure deep linking and the more generalist WalletConnect v2 protocol.

6.1 Petra Wallet Deep Link Integration
Petra Wallet, the official wallet from Aptos Labs, offers a secure deep linking API for dApp interactions on mobile. This protocol is not a simple URL-based call; it involves a cryptographic handshake to establish a shared secret, which is then used to encrypt all subsequent transaction payloads. This ensures that transaction data is protected in transit between the dApp and the wallet.   

6.1.1 Implementation Steps
1. Install Dependencies

The integration requires libraries for cryptography and generating random values.

Bash

npm install tweetnacl react-native-get-random-values buffer
# --- or ---
yarn add tweetnacl react-native-get-random-values buffer
Additionally, ensure your application has a polyfill for the Buffer object, typically in your index.js or main entry file:
global.Buffer = require('buffer').Buffer;

2. Configure Deep Link Handling

Your application must be configured to handle incoming deep links from Petra. This involves setting up URL schemes in your native project files. The process is platform-specific and should follow standard React Native deep linking guides. Your app will need to listen for incoming URLs and parse them to handle callbacks from Petra.   

3. State Management and Connection Flow

The application needs to generate a persistent public/private key pair for itself and store the shared secret received from Petra.

TypeScript

import React, { useState, useEffect, useCallback } from 'react';
import { Linking, Button, View, Text } from 'react-native';
import nacl from 'tweetnacl';
import 'react-native-get-random-values';
import { Buffer } from 'buffer';

const DAPP_URL_SCHEME = 'yourappscheme://';
const PETRA_BASE_URL = 'https://petra.app';

// Define your dApp's metadata
const DAPP_METADATA = {
  name: 'My Awesome DeFi App',
  url: 'https://yourapp.com',
  description: 'Swap tokens with Panora',
  icon: 'https://yourapp.com/icon.png',
};

const PetraIntegration = ({ txData }) => {
  const = useState(null);
  const = useState(null);
  const [petraPublicKey, setPetraPublicKey] = useState(null);
  const [connectedAddress, setConnectedAddress] = useState(null);

  // Generate a persistent keypair for the dApp
  useEffect(() => {
    const keyPair = nacl.box.keyPair();
    setDappKeyPair(keyPair);
  },);

  // Handle callbacks from Petra
  const handleDeepLink = useCallback((event) => {
    const url = new URL(event.url);
    const params = new URLSearchParams(url.search);
    const data = JSON.parse(Buffer.from(params.get('data'), 'base64').toString('utf8'));

    if (url.pathname.includes('connect_response')) {
      if (data.address && dappKeyPair) {
        const decryptedSharedKey = nacl.box.open(
          Buffer.from(data.petraPublicKey, 'hex'),
          Buffer.from(data.nonce, 'hex'),
          Buffer.from(data.dappEncryptionPublicKey, 'hex'),
          dappKeyPair.secretKey
        );
        setSharedSecret(decryptedSharedKey);
        setPetraPublicKey(Buffer.from(data.dappEncryptionPublicKey, 'hex'));
        setConnectedAddress(data.address);
      }
    } else if (url.pathname.includes('signAndSubmit_response')) {
      if (data.txnHash) {
        console.log('Transaction successful with hash:', data.txnHash);
        // Update UI to show success
      } else if (data.error) {
        console.error('Transaction rejected or failed:', data.error);
        // Update UI to show error
      }
    }
  }, [dappKeyPair]);

  useEffect(() => {
    const subscription = Linking.addEventListener('url', handleDeepLink);
    return () => subscription.remove();
  },);

  const handleConnect = () => {
    if (!dappKeyPair) return;
    const connectData = {
      appInfo: DAPP_METADATA,
      redirectLink: `${DAPP_URL_SCHEME}petra/connect_response`,
      dappEncryptionPublicKey: Buffer.from(dappKeyPair.publicKey).toString('hex'),
    };
    const encodedData = Buffer.from(JSON.stringify(connectData)).toString('base64');
    Linking.openURL(`${PETRA_BASE_URL}/connect?data=${encodedData}`);
  };

  //... (handleSwap function in next step)

  return (
    <View>
      {!connectedAddress? (
        <Button title="Connect Petra Wallet" onPress={handleConnect} />
      ) : (
        <Text>Connected: {connectedAddress}</Text>
      )}
      {/*... (Swap button) */}
    </View>
  );
};
4. Sign and Submit Transaction Flow

Once connected, the handleSwap function encrypts the txData payload using the shared secret and dispatches it to Petra.   

TypeScript

// Add this function inside the PetraIntegration component

const handleSwap = () => {
  if (!sharedSecret ||!dappKeyPair ||!txData) {
    console.error('Not connected or no transaction data available');
    return;
  }

  const nonce = nacl.randomBytes(nacl.box.nonceLength);
  const payloadString = JSON.stringify(txData);

  const encryptedPayload = nacl.box(
    Buffer.from(payloadString),
    nonce,
    petraPublicKey, // Petra's public key received during connect
    dappKeyPair.secretKey
  );

  const signAndSubmitData = {
    appInfo: DAPP_METADATA,
    redirectLink: `${DAPP_URL_SCHEME}petra/signAndSubmit_response`,
    dappEncryptionPublicKey: Buffer.from(dappKeyPair.publicKey).toString('hex'),
    nonce: Buffer.from(nonce).toString('hex'),
    payload: Buffer.from(encryptedPayload).toString('hex'),
  };

  const encodedData = Buffer.from(JSON.stringify(signAndSubmitData)).toString('base64');
  Linking.openURL(`${PETRA_BASE_URL}/signAndSubmit?data=${encodedData}`);
};

// Add a button to the JSX to trigger the swap
// <Button title="Execute Swap" onPress={handleSwap} disabled={!connectedAddress ||!txData} />
6.2 WalletConnect v2 Integration
WalletConnect v2 is a chain-agnostic protocol for connecting mobile wallets to dApps. While no dedicated Aptos-specific React Native library for WalletConnect exists, integration can be achieved by using a generic WalletConnect v2 library to manage the session and the official Aptos TypeScript SDK to format the transaction payload before sending it over the established connection.   

6.2.1 Implementation Steps
1. Install Dependencies

This approach requires the WalletConnect modal for React Native and the Aptos TS-SDK.

Bash

npm install @walletconnect/modal-react-native @aptos-labs/ts-sdk @react-native-async-storage/async-storage
# --- or ---
yarn add @walletconnect/modal-react-native @aptos-labs/ts-sdk @react-native-async-storage/async-storage
2. Configure WalletConnect Provider

Wrap your application's root component with the WalletConnectModal provider. This requires a projectId from https://cloud.walletconnect.com/.   

TypeScript

import React from 'react';
import { WalletConnectModal, IProviderMetadata } from '@walletconnect/modal-react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const projectId = 'YOUR_WALLETCONNECT_PROJECT_ID';

const providerMetadata: IProviderMetadata = {
  name: 'My Awesome DeFi App',
  description: 'Swap tokens with Panora on Aptos',
  url: 'https://yourapp.com',
  icons: ['https://yourapp.com/icon.png'],
  redirect: {
    native: 'yourappscheme://',
  },
};

const sessionParams = {
  namespaces: {
    aptos: {
      chains: ['aptos:1'], // aptos:1 for Mainnet, aptos:2 for Testnet
      methods:,
      events: ['chainChanged', 'accountChanged'],
      rpcMap: {
        'aptos:1': 'https://fullnode.mainnet.aptoslabs.com/v1',
      },
    },
  },
};

const App = () => {
  return (
    <>
      {/*... Your App Components... */}
      <WalletConnectModal
        projectId={projectId}
        providerMetadata={providerMetadata}
        sessionParams={sessionParams}
        storageOptions={{
          asyncStorage: AsyncStorage,
        }}
      />
    </>
  );
};
3. Connection and Transaction Logic

Use the useWalletConnectModal hook to manage the connection state and send transaction requests. The txData from your backend must be used to construct a transaction payload compatible with the Aptos SDK.

TypeScript

import { useWalletConnectModal } from '@walletconnect/modal-react-native';
import { Aptos, AptosConfig, Network, EntryFunctionPayloadResponse } from '@aptos-labs/ts-sdk';

const WalletConnectIntegration = ({ txData }) => {
  const { open, isConnected, address, provider } = useWalletConnectModal();

  const handleSwapWC = async () => {
    if (!isConnected ||!provider ||!txData) {
      console.error('Not connected or no transaction data');
      return;
    }

    // The txData from Panora API is already in the correct format.
    // We just need to ensure it matches the type expected by the SDK/wallet.
    const transactionPayload: EntryFunctionPayloadResponse = txData;

    try {
      const result = await provider.request({
        method: 'aptos_signAndSubmitTransaction',
        params: [transactionPayload],
      });
      console.log('Transaction submitted with hash:', result.hash);
      // Handle success
    } catch (error) {
      console.error('WalletConnect request failed:', error);
      // Handle rejection or error
    }
  };

  return (
    <View>
      {!isConnected? (
        <Button title="Connect with WalletConnect" onPress={() => open()} />
      ) : (
        <View>
          <Text>Connected: {address}</Text>
          <Button title="Execute Swap (WC)" onPress={handleSwapWC} disabled={!txData} />
          <Button title="Disconnect" onPress={() => provider?.disconnect()} />
        </View>
      )}
    </View>
  );
};
Backend Pattern: Secure Quote Management
While it is technically possible to call the Panora API directly from the React Native client, this approach is strongly discouraged for production applications. A backend service acting as a proxy is the recommended architecture to enhance security, performance, and maintainability.

7.1 Rationale for a Backend Proxy
Implementing a backend service provides two primary benefits:

Security: The most critical reason is to protect your Panora API key. If the API key is embedded within the mobile application's binary, it can be extracted by malicious actors through reverse engineering. A compromised API key could lead to abuse of the Panora service under your account's identity, potentially resulting in rate-limiting, service suspension, or other unforeseen consequences. By keeping the key on a secure server, the client is never exposed to it.

Performance and Control: A backend allows for server-side caching of swap quotes. While DeFi prices are volatile, a short-lived cache can significantly reduce latency for users making common swaps and protect the Panora API from excessive traffic, ensuring your application remains within its rate limits. It also provides a central point for logging, monitoring, and error handling.

7.2 Minimal Node.js/Express Endpoint
The following is a minimal, runnable example of a Node.js server using the Express framework. This endpoint securely proxies requests from the mobile client to the Panora API.

TypeScript

// backend/server.ts
import express from 'express';
import axios from 'axios';
import cors from 'cors';

const app = express();
app.use(express.json());
app.use(cors()); // Configure appropriately for production

const PANORA_API_URL = 'https://api.panora.exchange/swap';
const PANORA_API_KEY = process.env.PANORA_API_KEY;

if (!PANORA_API_KEY) {
  throw new Error('PANORA_API_KEY environment variable is not set.');
}

app.post('/api/quote', async (req, res) => {
  try {
    const { fromTokenAddress, toTokenAddress, fromTokenAmount, toWalletAddress, slippage } = req.body;

    // Basic validation
    if (!fromTokenAddress ||!toTokenAddress ||!fromTokenAmount ||!toWalletAddress) {
      return res.status(400).json({ error: 'Missing required swap parameters.' });
    }

    const response = await axios.post(
      PANORA_API_URL,
      {
        fromTokenAddress,
        toTokenAddress,
        fromTokenAmount,
        toWalletAddress,
        slippage,
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': PANORA_API_KEY,
        },
      }
    );

    res.status(200).json(response.data);
  } catch (error) {
    console.error('Error fetching quote from Panora:', error.response?.data |

| error.message);
    res.status(error.response?.status |

| 500).json({
      error: 'Failed to fetch swap quote.',
      details: error.response?.data,
    });
  }
});

const PORT = process.env.PORT |

| 3001;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
7.3 Caching Strategy
To improve response times and manage API usage, a caching layer should be implemented. For swap quotes, a very short Time-To-Live (TTL) is essential due to the high volatility of cryptocurrency prices.

Cache Key	TTL (Seconds)	Rationale
/swap quote	5-10	DeFi prices can change significantly within seconds. A short TTL ensures that users are presented with a reasonably fresh quote while still providing a performance benefit for frequent, identical quote requests and protecting against API rate limits.

Export to Sheets
An in-memory cache like node-cache can be used for simplicity, or a more robust external solution like Redis can be employed for distributed systems.

7.4 Error Handling
The backend must gracefully handle errors from the Panora API and propagate them to the mobile client in a structured format. This includes handling network errors, 4xx client errors (e.g., invalid token pair), and 5xx server errors from the Panora service. The example above demonstrates a basic pattern for capturing and forwarding these errors.

Security and Validation: A Pre-Flight Checklist
The security of a non-custodial swap integration is paramount. A comprehensive review of publicly available information revealed no formal security audit for the Panora smart contracts on the Aptos blockchain as of October 2025. This absence of a third-party audit places a significant responsibility on the integrating application to act as a crucial line of defense for the user. A malicious or compromised Panora API could, in theory, return a txData payload designed to drain user funds by targeting a malicious contract or manipulating function arguments.   

Therefore, it is mandatory for the React Native client to perform a series of validation checks on the txData received from the backend before dispatching it to the user's wallet for signing. This pre-flight checklist ensures that the transaction conforms to a known-safe structure.

Mandatory Client-Side Validation Logic
The following TypeScript function provides a template for the validation logic. It should be executed immediately after receiving the txData from the backend and before displaying the confirmation UI to the user.

TypeScript

// security/validator.ts

interface TxDataPayload {
  type: string;
  function: string;
  type_arguments: string;
  arguments: any;
}

const KNOWN_PANORA_ROUTER_ADDRESS = '0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b';
const WHITELISTED_FUNCTIONS =;

export function validatePanoraTxData(txData: TxDataPayload): { isValid: boolean; error?: string } {
  // Rule 1: Check payload type
  if (txData.type!== 'entry_function_payload') {
    return { isValid: false, error: 'Invalid payload type.' };
  }

  // Rule 2: Whitelist router address and function
  if (!WHITELISTED_FUNCTIONS.includes(txData.function)) {
    return { isValid: false, error: 'Function call is not whitelisted.' };
  }
  
  // Rule 3: Validate argument structure (example for swap_exact_coin_for_coin_x1)
  if (txData.arguments.length < 2) {
      return { isValid: false, error: 'Incorrect number of arguments.' };
  }
  
  const fromAmount = txData.arguments;
  const minToAmount = txData.arguments[1];

  // Ensure amounts are non-negative numbers represented as strings
  if (typeof fromAmount!== 'string' ||!/^\d+$/.test(fromAmount) ||
      typeof minToAmount!== 'string' ||!/^\d+$/.test(minToAmount)) {
    return { isValid: false, error: 'Invalid amount format in arguments.' };
  }

  // Rule 4: Add more specific checks as needed, e.g., validating the route data structure
  // if it can be decoded client-side.

  return { isValid: true };
}
txData Validation Rules
The following table summarizes the critical validation rules that must be implemented.

Rule	Check	Rationale
Router Address Whitelisting	The function field in txData must begin with the known-good Panora router address: $0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b.	This is the most critical check. It prevents the API from directing the user's transaction to an entirely different, potentially malicious, smart contract.
Function Name Whitelisting	The full function identifier must exist in a predefined list of known-safe swap functions (e.g., ...::router::swap_exact_coin_for_coin_x1).	This prevents the API from instructing the client to call a dangerous function on the correct contract, such as an administrative function like transfer_ownership or a function that could approve token spending to a malicious address.
Argument Sanitization	The arguments array must be inspected for correct types, count, and format. For a swap, this includes verifying that the fromTokenAmount and minToTokenAmount are non-negative integers (as strings). The minToTokenAmount should also be cross-referenced with the user's selected slippage tolerance to ensure it is not unexpectedly low.	This check protects against malformed or malicious arguments that could result in an unfair trade or unintended side effects. Validating the minimum output amount is crucial for protecting the user from excessive slippage.
Integrator Fee Validation	If the integrator fee feature is used, the client should verify that the fee parameters within the transaction arguments (if present) match the expected fee address and amount.	This prevents the Panora API from maliciously redirecting integrator fees or inflating the fee amount beyond what was agreed upon.

Export to Sheets
Testing and Staging Plan
A comprehensive testing strategy is essential to ensure the reliability, security, and correctness of the swap integration. Testing should cover the full end-to-end flow across different network environments and include both happy-path and edge-case scenarios.

9.1 Network Endpoints
All interactions with the Aptos blockchain require a connection to a fullnode. Developers should use the appropriate endpoint for each stage of development and testing.

Aptos Mainnet: https://fullnode.mainnet.aptoslabs.com/v1

Aptos Testnet: https://fullnode.testnet.aptoslabs.com/v1

Aptos Devnet: https://fullnode.devnet.aptoslabs.com/v1

Panora Testnet: No official testnet or staging endpoint for the Panora API has been identified. For development and testing, it is recommended to use the Aptos Devnet. This can be done by either using the transaction simulation endpoint against Devnet state or, for more comprehensive testing, deploying the official Panora contract integration example to a personal Devnet account.   

9.2 Transaction Simulation
The Aptos Fullnode API provides a powerful simulation endpoint that allows developers to preview the outcome of a transaction without signing it or submitting it to the blockchain. This is an invaluable tool for estimating gas fees, verifying transaction correctness, and debugging txData payloads.   

Endpoint: POST /v1/transactions/simulate

Usage: To simulate a transaction, construct a raw transaction payload from the txData and a placeholder signature. The Aptos TypeScript SDK provides a high-level wrapper for this process.

TypeScript SDK Simulation Snippet:

TypeScript

import { Account, Aptos, AptosConfig, Network } from '@aptos-labs/ts-sdk';

const aptos = new Aptos(new AptosConfig({ network: Network.DEVNET }));

async function simulateSwap(txData: any, senderAddress: string) {
  // A dummy account is needed for the SDK to construct the simulation request.
  // The private key is irrelevant as it is not used for signing.
  const dummySender = Account.generate();

  const rawTransaction = await aptos.transaction.build.simple({
    sender: senderAddress,
    data: txData,
  });

  try {
    const = await aptos.transaction.simulate.simple({
      signerPublicKey: dummySender.publicKey, // A placeholder public key
      transaction: rawTransaction,
    });

    console.log('Simulation successful:', simulationResponse.success);
    console.log('Gas used:', simulationResponse.gas_used);
    return simulationResponse;
  } catch (error) {
    console.error('Simulation failed:', error);
    return null;
  }
}
9.3 Integration Test Matrix
The following matrix outlines a set of essential test cases for validating the integration.

Test Case ID	Scenario	Expected Outcome	Test Method
TC-01	Happy Path: Swap	Swap 1 Testnet APT for a stablecoin.	The wallet (Petra/WalletConnect) prompts for signing, the transaction is submitted successfully, and the user's balances update correctly on-chain.
TC-02	User Action: Rejection	User clicks "Reject" in the wallet prompt.	The application receives a rejection callback/error and displays an appropriate "Transaction Rejected" message to the user.
TC-03	Edge Case: Insufficient Balance	Attempt to swap more APT than the user possesses.	The transaction simulation should fail with an "out of gas" or insufficient balance error. If submitted, the wallet should reject it, or the transaction will fail on-chain.
TC-04	High Slippage	Execute a large swap on an illiquid pair.	The confirmation screen should display a high price impact warning. The transaction may fail on-chain if the price moves beyond the slippage limit during execution.
TC-05	API Error: Invalid Pair	Request a quote for a token pair that has no liquidity route.	The application backend should receive a 4xx error from the Panora API and propagate a user-friendly error to the client (e.g., "No trade route found").
TC-06	Security: Malformed txData	Intercept and modify the txData to point to a non-whitelisted contract address.	The client-side validatePanoraTxData function must fail, preventing the transaction from ever being shown to the user.
TC-07	Network Failure: API Unreachable	The Panora API endpoint is down or unreachable.	The application backend should time out and return a 5xx error to the client, which should display a "Service Unavailable" message.
TC-08	Wallet Disconnected	User attempts to swap after disconnecting their wallet.	The "Swap" button should be disabled, or pressing it should prompt the user to connect their wallet first.
TC-09	Deep Link Cold Start	User initiates a swap via Petra deep link while the app is closed.	The app should launch, handle the connection/transaction, and correctly process the callback upon returning from Petra.
TC-10	WalletConnect Session Restore	User closes and reopens the app.	The WalletConnect session should be restored automatically, and the user should not need to reconnect to perform a swap.

Export to Sheets
Production Operations and Monitoring
Deploying the integration is the beginning of its lifecycle, not the end. A proactive approach to operational readiness and monitoring is essential for maintaining a reliable and high-quality user experience.

10.1 Operational Readiness
Rate Limits: Both the Aptos Fullnode API and the Panora API will enforce rate limits. The backend service should monitor for HTTP 429 Too Many Requests responses. Implement a robust retry mechanism with exponential backoff and jitter to handle these errors gracefully and avoid overwhelming the services during periods of high traffic.

Monitoring: Instrument the backend service to track key performance indicators (KPIs). Essential metrics include:

Panora API Latency: The p50, p90, and p99 latency for requests to the /swap endpoint.

Swap Success Rate: The percentage of initiated swaps that are successfully committed on-chain. This requires tracking transaction hashes and querying their status.

Error Rate: The percentage of requests to the backend's /api/quote endpoint that result in 4xx or 5xx errors.

Average Gas Cost: Track the average gas used per successful swap to monitor network costs.

Alerting: Configure alerts based on the monitored metrics. For example, an alert should be triggered if the Panora API error rate exceeds a certain threshold (e.g., 5% over a 10-minute window) or if the swap success rate drops significantly.

10.2 Go-Live Checklist
Before enabling the feature for production users, perform a final review using this checklist:

[ ] Configuration Verified: All backend environment variables point to production services (Aptos Mainnet fullnode, production Panora API key).

[ ] Client-Side Endpoints: The React Native client is configured to communicate with the production backend endpoint.

[ ] WalletConnect Project ID: The production WalletConnect projectId is configured in the client.

[ ] Feature Flag: The swap feature is controlled by a remote feature flag to allow for rapid disabling in case of an emergency.

[ ] Monitoring Dashboards: Dashboards for the key metrics listed above are active and accessible.

[ ] Final E2E Test: A small but real swap has been successfully executed on Mainnet using a production build of the application.

10.3 Rollback Plan
In the event of a critical issue post-launch (e.g., a widespread failure of swaps, a security vulnerability), a simple and rapid rollback plan is essential.

Immediate Mitigation: Disable the swap feature for all users by toggling the remote feature flag. This is the fastest way to contain the issue.

Code Reversion: If the issue is caused by a bug in the client or backend code, trigger a deployment of the last known stable version of the affected service(s).

Post-Mortem: Once the issue is contained, conduct a thorough post-mortem analysis to understand the root cause and implement preventative measures for the future.

Troubleshooting and FAQ
This section addresses common issues that may arise during development and testing.

Q: The Petra deep link does nothing or opens the App Store.

A: This is almost always an issue with the native configuration of URL schemes. Double-check that the yourappscheme has been correctly added to the Info.plist file on iOS and the AndroidManifest.xml file on Android, following standard React Native deep linking setup guides.   

Q: I'm getting a "decryption failed" or similar cryptographic error when handling the Petra callback.

A: This indicates a problem with the encryption/decryption process. Verify the following:

The Buffer object is correctly polyfilled in your application's entry point.

You are using the correct keys: the dApp's secret key and Petra's public key (received during the connect handshake) for opening the box (decrypting).

The nonce and public keys are being correctly converted to and from hex/Buffer formats without data corruption.

Q: WalletConnect shows a "Unsupported Chain" error.

A: Ensure that the wallet you are testing with has explicit support for the Aptos network. In your WalletConnectModal configuration, verify that the namespace is correctly specified as aptos and the chain ID is aptos:1 for Mainnet.

Q: My transaction simulation fails with an "INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE" error.

A: The simulation endpoint executes the transaction against the current state of the blockchain. This error means the senderAddress provided for the simulation does not have enough APT on the target network (e.g., Devnet) to cover the estimated gas fees. Use a faucet to fund the account before running the simulation.

Q: A swap transaction fails on-chain with a "SLIPPAGE" error.

A: This means the price of the assets moved between the time the quote was generated and the time the transaction was executed on-chain. The actual output amount fell below the minToTokenAmount specified in the transaction arguments. This is more common in volatile markets or with illiquid tokens. You can mitigate this by increasing the slippage tolerance, but this should be a user-configurable setting.

Changelog and Known Issues
Maintaining awareness of changes in dependencies is crucial for the long-term stability of the integration.

Panora
Panora Exchange does not maintain a public, formal changelog for its API or smart contracts. This presents an ongoing operational risk. Developers should actively monitor the official Panora Exchange GitHub organization for commits to the Panora-Contract-Integration-Example or other relevant repositories, as these may signal upcoming or recent changes to the on-chain functions or txData structure.   

Aptos Dependencies
@aptos-labs/ts-sdk: As of the latest review, the current version is 5.0.0. This SDK is actively maintained by Aptos Labs. Consult the official NPM page or GitHub repository for release notes before upgrading.   

@aptos-labs/wallet-adapter-react: The current version is 7.1.0. While not directly used in the React Native implementation, it is a related project, and its changelog can provide context on wallet interaction standards in the Aptos ecosystem.   

Known Issues
Primary Known Risk: Lack of Public Security Audit: As detailed in Section 8, there is no known public security audit for the Panora smart contracts as of October 2025. This is the single most significant risk associated with this integration. The client-side validation rules outlined in this guide are a critical mitigation but do not replace the assurance provided by a comprehensive, professional audit. The project team must accept this residual risk before proceeding.

Appendices
The appendices, provided as separate files in the deliverable package, contain raw data and complete source code for reference and deeper analysis.

13.1 Raw API Responses
raw/aptos-fullnode-modules-response.json: Contains the full, unabridged JSON response from the Aptos Mainnet fullnode for the command to fetch modules from the Panora router address.

13.2 Raw On-Chain Module Blobs
raw/panora-router-bytecode.txt: Contains the base64-encoded Move bytecode for the router module, as fetched from the fullnode.

13.3 Complete Source Code
The examples/ directory contains full, self-contained, and runnable source code for the components described in this guide.

examples/react-native/petra/PetraIntegration.tsx: A complete React Native component demonstrating the full Petra Wallet deep link flow, including connection, encryption, transaction submission, and callback handling.

examples/react-native/walletconnect/WalletConnectIntegration.tsx: A complete React Native component demonstrating the WalletConnect v2 flow, including provider setup, connection, and transaction submission.

examples/backend/node/server.ts: A runnable Node.js/Express server implementing the secure backend proxy for managing the Panora API key and handling quote requests.

References and Citations
All claims and technical specifications in this guide are based on the following authoritative sources, retrieved and validated within the last 90 days unless otherwise noted as a foundational protocol detail.

Bolded sources are the five most critical, load-bearing documents upon which this guide is built.

Petra Mobile Deep Links Documentation. Petra Wallet. (Retrieved 2025-10-06).    

Data Analyst Guide to Aptos: DeFi Swaps (pt.2). Aptos Labs. (Retrieved 2025-10-06).    

Aptos Fullnode REST API Specification. Aptos Developer Documentation. (Retrieved 2025-10-06).    

Aptos TypeScript SDK Documentation. Aptos Developer Documentation. (Retrieved 2025-10-06).    

Panora-Contract-Integration-Example GitHub Repository. PanoraExchange. (Retrieved 2025-10-06).    

Aptos Wallet Adapter for Dapp Builders. Aptos Developer Documentation. (Retrieved 2025-10-06)..   

@aptos-labs/wallet-adapter-react NPM Package. (Retrieved 2025-10-06)..   

Deep Linking. React Navigation Documentation. (Retrieved 2025-10-06)..   

Simulating Transactions. Aptos Developer Documentation. (Retrieved 2025-10-06)..   

System Integrators Guide. Aptos Developer Documentation. (Retrieved 2025-10-06)..   

WalletConnect v2 Chain Agnosticism. WalletConnect Blog. (Retrieved 2025-10-06)..   

PanoraExchange GitHub Organization. (Retrieved 2025-10-06)..   

