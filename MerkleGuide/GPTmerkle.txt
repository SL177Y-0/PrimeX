To create an up-to-date, step-by-step guide for replicating Merkle Trade's leverage trading (especially for the APTOS/USDC pair with Petra Wallet integration) into your own app, could you please clarify the following:

Platform Target: Is this for a web app, mobile app (e.g., React Native), or both?

Feature Scope: Should the guide include just order placement (open/close positions), or should it also include features like add collateral, partial close, SL/TP updates, liquidation monitoring, etc.?

Backend Stack: Are you planning to run a backend service that processes user trade data or will everything be client-side only?

Environment Details:

Do you already have testnet and mainnet access configured?

Should I include testnet faucet details and contract deployment instructions for test environments?

UI/UX Layer:

Do you want React examples or only backend API integration?

Should wallet connect via Petra be explained for mobile via WalletConnect/deep link or web?

Once I have this, I can generate a complete, updated integration and replication guide for both testnet and mainnet as of October 2025.

You said:
react native app , it should have everything merkle have , give me both for client side and backend service , both networks guide , i have already usinng deep link of petra
ChatGPT said:

Perfect. I’ll compile a complete October 2025 developer guide to replicating Merkle Trade’s leverage trading features in your React Native app.

This guide will include:

Full client-side and backend implementation steps.

Support for both Aptos testnet and mainnet.

Deep integration of the APTOS/USDC trading pair.

Petra wallet integration via deep links.

Coverage of all key Merkle features: open/close positions, add collateral, partial close, stop loss/take profit, liquidation monitoring, event tracking, and order history.

I'll get started and let you know once the guide is ready for review.

Research completed in 11m · 16 sources · 51 searches
ChatGPT said:

Merkle Trade Leverage Trading Integration for React Native App

Merkle Trade Leverage Trading Integration Guide (React Native, Aptos – Oct 2025)
Client-Side Integration
Trading Flows: Open, Close, Add Collateral, Partial Close, SL/TP Updates

In Merkle’s system, users place orders to open or close leveraged positions, which are then executed by network keepers. To open a position, the client calls the trading::place_order entry function (latest version) on Aptos with parameters for the desired trade (pair, size, collateral, long/short, etc.). This emits an order event that keepers listen for
github.com
. A keeper then fetches the live market price from Pyth oracle and calls execute_order to fill the order, converting it into an active Position
github.com
. This two-step process ensures the position opens at the real-time price. For market orders, the system behaves similarly except the execution is immediate at current price (still via keeper). For limit orders, the place_order includes a target price and remains pending until a keeper executes it when the price condition meets.

 

Closing a position (full or partial) follows a similar flow. The user submits a decrease order via place_order (with is_increase = false) specifying how much of the position to close (a partial close uses a size smaller than the full position). This emits another order event that a keeper executes, closing the position (fully or partially) at the latest price
github.com
. When partially closing, the contract supports a “keep leverage” option – meaning it returns a proportional amount of collateral so the remaining position keeps the same leverage. This is toggled via a boolean flag in the order payload (e.g. keep_leverage), ensuring the leftover position retains its risk ratio.

 

Adding collateral to an active position is done by placing an “increase” order with size_delta = 0 and a positive collateral_delta. This effectively only adjusts collateral without changing the position size
docs.merkle.trade
. The user’s call to place_order in this case emits an order event that a keeper executes, resulting in additional collateral applied to the position. Conversely, updating Stop-Loss/Take-Profit (SL/TP) uses a separate entry function (e.g. trading::update_position_tp_sl). This call immediately emits an UpdateTPSLEvent containing the new SL and TP trigger prices for the position. The SL/TP values are stored on-chain and monitored by keepers.

 

Trade Execution Events: After each keeper execution, a PositionEvent is emitted to record the outcome (open or close). Your app should listen for or fetch these events to confirm when a position is opened or closed. A “PositionOpened” event corresponds to an increase that results in a new or bigger position (with is_increase = true), while “PositionClosed” events correspond to decreases (is_increase = false) which could be full closings or partial reductions. The event data includes fields like the user address, whether it’s long or short, the executed price, size change, collateral change, and resulting PnL and fees (detailed in Merkle Contract Reference below). You’ll use these events both on the client (for immediate UI updates) and in your backend indexer for historical data.

Position History, Status & Liquidation Alerts

The app should display the user’s open positions and position history by fetching on-chain data and cached backend data. To show current positions and their status (entry price, current PnL, etc.), query the backend service or directly call Merkle’s on-chain resources. Each user has a UserStates resource tracking open positions (keys for each pair/side), or you can use Merkle’s API/SDK (e.g. getPositions) to retrieve them
github.com
. For each active position, compute the unrealized PnL by comparing current price to entry price (see Backend section for how to obtain price). Also, fetch any pending take-profit or stop-loss values (from the last UpdateTPSLEvent or from the position resource if stored) to display.

 

Position history (closed trades) can be built from the stream of past PositionEvents. Each PositionEvent where is_increase = false and is_partial = false (or an event type indicating a full close) represents a position closing. By indexing these events, you can list past trades with their entry/exit prices, PnL, fees, etc. Merkle’s TypeScript SDK even provides getTradingHistory for convenience
github.com
, but you can implement this by querying events.

 

Liquidation alerts: A position is at risk of liquidation when its equity (collateral + PnL – fees) falls below 10% of its initial collateral
docs.merkle.trade
. In practice, this corresponds to about a 90% loss of collateral (Merkle’s liquidation threshold factor is 10% for all pairs
docs.merkle.trade
). Your app should warn the user if their position’s estimated liquidation price is near the current price. The liquidation price can be computed based on entry price, leverage, fees, and the 10% threshold
docs.merkle.trade
. For example, for a long position:

 

liqPrice
=
entryPrice
×
(
1
−
PositionSize
Collateral
×
0.10
−
fees
𝑒
𝑥
𝑖
𝑡
−
funding
𝑎
𝑐
𝑐
𝑢
𝑚
)
liqPrice=entryPrice×(1−
Collateral
PositionSize
	​

×0.10−fees
exit
	​

−funding
accum
	​

)

 

(as given in Merkle’s docs
docs.merkle.trade
). The backend (or client) can calculate this continually using the latest price and funding fee accrual. By comparing current market price to the liq price, the app can trigger liquidation warnings when close. Additionally, the backend can monitor for on-chain liquidation events (which would appear as a closing PositionEvent triggered by a keeper) and inform the user if their position was liquidated.

Petra Wallet Integration (Mobile Deep Links)

For a smooth mobile experience, integrate the Petra Aptos wallet via deep links. Petra mobile supports deep link URIs that allow your React Native app to connect, sign transactions, and more
petra.app
. Ensure your RN app is configured for deep linking (using something like React Navigation’s linking). Petra’s deep link format uses the custom URL scheme petra://api/v1 with specific endpoints:

petra://api/v1/connect – prompts Petra to connect and authorize your dApp (establishing a session).

petra://api/v1/signAndSubmit – sends a transaction payload to Petra for signing and submission
petra.app
.

petra://api/v1/disconnect – disconnects the wallet.

The data payload must be attached as a Base64-encoded JSON string in a data query param
petra.app
. Petra’s docs outline the JSON structure expected. For example, to request a signature, you include fields like your dApp domain and name (so Petra can display who is requesting), a one-time requestId, and the Aptos transaction in hex or BCS format. After constructing the deep link URL, use React Native’s Linking API to open it, which will switch the user to Petra. Once the user approves and signs, Petra will redirect back to your app via your app’s own deep link scheme, carrying the transaction result (or error) in the callback URL
petra.app
.

 

Implementing the Wallet Flow: First, ensure the user has Petra installed and an account set up. In your app, provide a “Connect Wallet” button – when tapped, open petra://api/v1/connect?... to let the user authorize. Petra will return with the user’s Aptos address, which you store in state. For signing a transaction (like placing an order), prepare the transaction payload (as discussed below) and encode it in Petra’s expected format, then open the signAndSubmit deep link. Listen for the response deep link in your RN app (via Linking.addEventListener) to confirm the transaction hash or any error. Petra’s documentation provides a step-by-step guide and even a sample React Native implementation for this mobile-to-mobile connection
petra.app
petra.app
. Using the Aptos Wallet Adapter is another approach (it offers a React Native compatible module for multiple wallets
npmjs.com
), but Petra’s deep link is the currently recommended method for mobile.

UI Wiring Example: From Form Input to On-Chain Event

To illustrate the end-to-end flow, consider the “Open Position” form in your app. The user enters parameters (e.g. Pair = APT/USDC, Amount = 5 USDC collateral, Leverage = 60x for a $300 position, Direction = Long, Order Type = Market). When the user submits:

Prepare Transaction Payload: Using the Aptos SDK, construct an entry function payload for place_order. For example, using Merkle’s TS SDK for convenience:

const payload = await merkle.payloads.placeMarketOrder({
    pair: "APT_USD",
    userAddress: userAddress,
    sizeDelta: 300_000_000n,       // 300 USDC (in u64 scaled to 1e6)
    collateralDelta: 5_000_000n,  // 5 USDC (u64 scaled)
    isLong: true,
    isIncrease: true
});


This payload object contains the function 0x...::trading::place_order_v3<APT, USDC> and the arguments for size, collateral, etc., properly formatted. (Under the hood, sizeDelta and collateralDelta are in minor units; e.g. 300 USDC = 300 * 10^6 in the 6-decimals USDC coin.) If not using the SDK, you can build the payload manually: set the function to Merkle’s place_order entry (with the correct generics for the APT/USDC market types), and include the arguments:

size_delta (u64)

collateral_delta (u64)

leverage or dummy (u64 – older versions may include a leverage or slippage param)

is_long (bool)

is_increase (bool – true for opening/add collateral)

is_market (bool – true for market order, false for limit)

limit_price (u64, if limit order; can be 0 for market)

expiration_timestamp (u64, optional; or 0 if not used)

keep_leverage (bool – true to keep same leverage on partial close)

These parameters align with the place_order_v3 function signature in the ABI. For example, an entry might look like:

{
  "type": "entry_function_payload",
  "function": "0x5ae6...bbc06::trading::place_order_v3<0x...::pair_types::APTUSD, 0x...::usdc::USDC>",
  "arguments": [
     userAddress, 
     300000000, 
     5000000, 
     0, 
     true, 
     true, 
     true, 
     0, 
     0, 
     false
  ]
}


(Here is_long=true, is_increase=true, is_market=true, and keep_leverage=false since this is a new position.)

Trigger Wallet Signing: Once the payload is ready, use Petra’s deep link to sign and submit. For instance, create a JSON like { network: "Mainnet", payload, requester: APP_INFO, ... }, Base64-encode it, and attach to petra://api/v1/signAndSubmit?data=<encoded>. Open this URL to launch Petra
petra.app
. Petra will prompt the user to approve the transaction (showing details like the contract address and function being called). After user approval, Petra signs the transaction with their private key and submits it to the Aptos network.

Handle Transaction Result: Petra will redirect back to your app (to a URL like myapp://...) carrying the transaction hash or an error. Upon receiving the hash, use the Aptos REST API or SDK to fetch the transaction details. For example, call the Aptos /v1/transactions/by_hash/{hash} REST endpoint or use aptos.waitForTransaction(hash) in the SDK
github.com
. The confirmed transaction data will include any events emitted
github.com
. In this case, the user’s place_order transaction emits an OrderPlaced event (to the place_order_events handle) containing the order ID and details.

UI Feedback: Optimistically, you can inform the user that their order was placed successfully (“Position opening…”) once the transaction is confirmed. However, the position isn’t open yet until a keeper executes it. The actual PositionOpened event will occur in a separate transaction by the keeper. You have two ways to update the UI when the position goes live:

Polling/Backend push: Your backend indexer (discussed below) will catch the PositionEvent for the open. It can notify the app (via WebSocket or the app can poll an API) that the position is now active.

Merkle WebSocket API: Alternatively, leverage Merkle’s provided account feed. Merkle offers real-time account updates via WebSocket – e.g. subscribeAccountFeed will push updates for orders and positions
github.com
. If accessible, this feed can inform your app as soon as the order is executed and a position is opened.

Event Parsing: Once you receive the PositionOpened event (either via backend or Merkle feed), parse its fields to update the UI. For example, the event will include the executed price and final size. Update the position entry in the UI with the average entry price, collateral used, etc. Similarly, when a user closes or partially closes a position, you will parse the PositionClosed (or “decreased”) event to show realized PnL, returned collateral, and update the open position’s status (or remove it if fully closed).

Throughout this flow, make sure to handle error cases (e.g. transaction failure or if the order couldn’t be executed in time). Cancel Order functionality is available via trading::cancel_order if a limit order is waiting – your UI can show a cancel button that triggers this entry function (similar signing flow) to abort a pending order.

Backend Service Setup

Setting up a robust backend service is crucial for tracking all trading activity on-chain and serving data efficiently to the app.

Event Indexing and Cache

Aptos Event Tracking: Merkle’s smart contracts emit events for every significant action – order placements, cancellations, position executions (opens/closes), and SL/TP updates. Your service should connect to an Aptos full node or use the Aptos Indexer API to stream these events. Specifically, monitor the Merkle protocol’s deployer account 0x5ae6789dd2fec1a9ec9cccfb3acaf12e93d432f0a3a42c92fe1a9d490b7bbc06 (which houses all Merkle modules
docs.merkle.trade
) for events of the relevant types. The main events and their Move struct types are:

OrderEvent (for place_order_events) – indicates a user placed an order (includes order_id, user, pair, size, etc.).

PositionEvent (for position_events) – emitted when a position is executed/updated (includes details of open/close).

CancelOrderEvent (for cancellations).

UpdateTPSLEvent (for SL/TP changes).

Merkle’s design actually keeps per-user event handles (UserTradingEvents resource in each user’s account) as well as global event handles. To index all events in one place, you can subscribe to the global handles located in the deployer’s TradingEvents resource. Using the Aptos API, you can query events by account address + event handle path, or use the GraphQL Indexer to query by event type name. For example, query all events of type 0x5ae6...::trading::PositionEvent to get every position event on-chain
dune.com
. Store these in your database as they come in (with fields decoded to human-readable form).

 

Database Schema: You’ll want to index trades by user address for efficient queries. For instance, have tables or collections for positions (active positions), positions_history (closed positions), and orders. When a PositionEvent comes in:

If it’s an open/increase event (is_increase=true), either create a new position record or update an existing one (if adding collateral or increasing size on an existing position) for the user address.

If it’s a close/decrease event (is_increase=false), update the corresponding position record by reducing the size or marking it closed. If is_partial=true, the position remains open with a smaller size; if is_partial=false (full close), mark it closed and maybe move it to history. Record the realized PnL from pnl_without_fee and any fees.

Use the order_id field to link position open and close events to the original order. Each OrderEvent has an order_id; the PositionEvent from its execution will carry the same order_id, allowing you to tie them together.

Similarly, capture UpdateTPSLEvent for users – when you see one, update the stored SL/TP values for that user’s position (keyed by user + pair + side) so your API can serve the latest SL/TP settings.

 

By indexing all events, your backend can answer questions like “list all positions for user X”, “get history of trades for user X”, “has order #123 been executed?”, etc. It’s wise to cache computed results (like current PnL, see below) to avoid heavy on-the-fly calculations.

Position PnL, Liquidation & Funding Calculations

Your service must compute certain derived metrics to fully inform the frontend:

Unrealized PnL: For each open position, calculate PnL = f(current_price, entry_price, size). Merkle’s PnL is based on the change in price times the position size (notional). If the position was opened at price P_entry and current price is P_now, and the position size = notional value in collateral (e.g. USDC), then for a long: PnL = (P_now - P_entry) / P_entry * position_notional. For a short, the PnL formula is inverted (profits when price drops). The PositionEvent doesn’t continuously update PnL, so you derive it using live prices. Price feed integration is needed here: subscribe to the Aptos oracle data that Merkle uses (they utilize Pyth Network for prices
github.com
). You can use Pyth’s client to get real-time APT/USD updates, or use Merkle’s public price WebSocket (subscribePriceFeed) for convenience
github.com
. With each price tick, update PnL for each open position and check if any are near liquidation.

Funding fees: Merkle charges a funding fee to balance long vs short open interest
docs.merkle.trade
. The funding rate evolves over time (velocity-based model) and accumulated funding is settled when positions close
docs.merkle.trade
docs.merkle.trade
. When a position is closed, the PositionEvent includes funding_fee and a boolean is_funding_fee_profit indicating if the trader paid or received funding. Your backend should incorporate this into the PnL calculation: effective PnL = trading PnL ± funding_fee (subtract if the trader paid, add if received). For current positions, you can estimate accrued funding by tracking the global funding rate. The contract maintains an accumulated funding per size value that increments as funding accrues. This can be read from the on-chain resource (likely in the trading module’s state for the pair). To simplify, you may use Merkle’s trading_calc functions like calculate_funding_fee if calling on-chain is feasible, or replicate the formula off-chain (Merkle’s docs provide a formula for funding rate changes
docs.merkle.trade
). In practice, many implementations choose to only finalize funding fee on close; thus the backend can ignore unrealized funding for simplicity, and just use the reported funding_fee at close for history records.

Liquidation checks: As discussed, compute each position’s liquidation threshold. Initially, a position can tolerate a 90% loss of collateral before liquidation
docs.merkle.trade
. However, funding fees and added collateral will shift the threshold slightly. The contract likely stores a liquidation_threshold constant (10%) and possibly adjusts for fees. Use the formula from Merkle’s docs
docs.merkle.trade
 (see above) to calculate liq_price whenever price or position size/collateral changes. If current price is near or below this, flag the position as liquidatable. Your backend can also directly catch actual Liquidation events: these would manifest as PositionEvents triggered by the keeper via execute_exit_position due to price hitting SL/TP or liq
github.com
github.com
. In Merkle, a liquidation is essentially a forced close with event_type denoting liquidation. By examining PositionEvents: a liquidated position typically has is_increase=false (a closing) with is_profit=false (a loss) and likely a specific event_type code (for example, community dashboards note event_type = 2 or 3 for liq/SL) – but even without the code, you can detect liquidation if equity was near zero. When such an event is caught, update the position as closed by liquidation and record that in history.

Serving Data to the Frontend

With the above indexing and calculations, design a simple API for the app:

GET /positions?user=<address> – returns all open positions for the user, with fields like entry price, current size, collateral, unrealized PnL, SL, TP, liq price, etc.

GET /history?user=<address> – returns past closed positions/trades for the user, including entry/exit info, realized PnL, fees, and timestamps.

GET /orders?user=<address> – (optional) returns any pending orders not yet executed or recently placed.

GET /metrics?user=<address> – (optional) aggregate info like total PnL, etc.

The backend can serve these from its database, refreshing as new events come in. This offloads heavy lifting from the mobile app. Ensure that when a new event comes (like position opened/closed), the backend can push notifications or use WebSocket to inform the app, so the UI updates in real-time without constant polling.

 

Finally, include admin or utility endpoints if needed, e.g., to trigger the testnet faucet for a user (if you integrate that for testing).

Support for Testnet and Mainnet

Your integration should be flexible to run on Aptos testnet for development and mainnet for production. Key differences and configurations:

Network Endpoints: Aptos testnet and mainnet have different RPC URLs (for example, https://fullnode.testnet.aptoslabs.com vs mainnet URL). If using the Aptos SDK, set the client’s endpoint accordingly. Also, Petra will target a specific network – ensure the transaction payloads specify the correct chain ID (testnet vs mainnet) so Petra knows where to submit.

Contract Addresses: The Merkle deployer address on mainnet is 0x5ae6...bbc06
docs.merkle.trade
 (all modules live here). On testnet, Merkle likely has a different deployer account (check Merkle’s docs or SDK for the testnet address). The Merkle TS SDK provides an easy config: MerkleClientConfig.testnet() vs .mainnet() automatically set the correct addresses and endpoints
github.com
github.com
. You can mimic this by maintaining a config file or constants: e.g.

const MERKLE_ADDRESS = isTestnet 
    ? "<testnet_deployer_address>" 
    : "0x5ae6789dd2fec1a9ec9cccfb3acaf12e93d432f0a3a42c92fe1a9d490b7bbc06";


and similarly for any Oracle feed or other addresses (USDC token type, etc.) that may differ in testnet.

Testnet Faucets: On testnet, you’ll need APT for gas and a source of USDC (or a test stablecoin) to serve as collateral. Use the official Aptos faucet for APT. For USDC, Merkle provides a helper to mint test tokens. In fact, the Merkle SDK includes a testnetFaucet payload function
github.com
 – this likely mints test MKL or gives some USDC to the caller. You can call Merkle’s faucet module (if provided) or have users obtain test USDC from a faucet (sometimes Aptos testnet has a “wrapped USDC” faucet in dev forums). If unavailable, you might deploy a simple coin on testnet as a stand-in for USDC for local testing.

Merkle Test Contracts: Ensure you deploy or use the correct version of Merkle contracts on testnet. Merkle Trade often keeps an updated testnet deployment for public beta
medium.com
. Check their docs or Discord for the testnet contract address and oracle setup. The testnet environment might also use mock price feeds – if Pyth is not providing data on testnet, Merkle might run a centralized price updater. In absence of Pyth on testnet, you might simulate price updates by allowing your backend to call an admin function to set price (Merkle’s managed_price_oracle.move module might allow price injection on testnet). However, if possible, use Pyth’s devnet prices or a test feed (Pyth often has a “testnet” price feed for each symbol).

Configuration Switching: Implement a simple toggle or build configuration for network. For example, use an environment variable or build flag in your app (REACT_NATIVE_APP_NETWORK=testnet or mainnet). On app startup, load network-specific constants (node URL, Merkle address, coin types, etc.). Similarly, point your backend service to the appropriate RPC and database (you may maintain separate databases for testnet vs mainnet data).

Mock Data Sources: In a local development scenario (if you run a local Aptos node), you might not have Merkle’s contracts deployed. In that case, consider deploying Merkle’s Move modules to a local node (if available/open source) or using a mock trading service. However, since Merkle’s code isn’t open source in Move (the ABI is public but source is closed), you’ll likely stick to Aptos testnet. Use the testnet as your “staging” environment with real Merkle contracts and perhaps reduced risk. You can generate some fake historical data for UI development, but ultimately testing against the real contract on testnet is best.

By clearly separating network config, you can easily switch to mainnet when ready – just update the RPC endpoint and ensure the user has a Petra wallet set to mainnet, then all the same integration logic works.

Focus on the APT/USDC Trading Pair

For this guide and initial development, we focus on the APTOS/USDC perpetual market, as it’s one of Merkle’s primary pairs. This simplifies the implementation since you can hardcode certain pair-specific details:

Pair Type & Metadata: Merkle’s Move contract likely represents the APT/USD market via a type or resource. In their system, trading pairs are configured in the pair_types module and the trading resource holds per-pair state
github.com
. The APT/USDC pair can be identified by a TypeInfo (for APT as base asset and USDC as collateral). In transactions, you will often supply this via generics. For example, the entry function might be place_order_v3<APT, USDC> where APT and USDC are the struct types for the coin and asset. Since you’re focusing on APT/USDC exclusively, you can embed those types in your code (and the corresponding addresses for them on testnet/mainnet). USDC on Aptos is typically represented by the FA standard coin or a wrapped coin. On mainnet, USDC is often 0x1::coin::USDC or a similar address (Merkle used a “W_USDC” in their LP token type
docs.merkle.trade
). Consult Merkle’s contract addresses or SDK for the exact type. For testnet, an equivalent coin type exists (it might be a test USDC with a different address).

Fetching Market Info: You might want to display market stats (price, 24h change, open interest, etc.) for APT/USDC. Merkle’s backend (or on-chain state) provides this. For instance, the trading resource likely holds current long and short open interest for each pair, which are updated as positions open/close. In the PositionEvent, fields long_open_interest and short_open_interest show the open interest after that event. You can use these to keep track of total OI. Additionally, Merkle’s SDK has getPairInfo and getPairState methods
github.com
 – these likely return info such as max leverage (APT/USDC is often 150x
merkle.trade
), current funding rate, skew, etc. Use these to display current funding rate and any price impact parameters. For example, show the current funding rate (%) for APT/USDC, which you can fetch from the on-chain funding_rate field (a signed integer in the resource) converted to a percentage per day.

Price Feeds: As mentioned, integrate the APT/USD price feed. Because APT/USDC is a crypto-stable pair, the price feed is in USD terms. Merkle uses Pyth’s Aptos price feed for APT/USD
github.com
. You should subscribe to that for real-time updates. If using Merkle’s feed, call subscribePriceFeed("APT_USD") which will likely yield a stream of price updates that mirror the oracle
github.com
. This ensures your app and backend always use the same price as the contract does for consistency (especially important around rapid moves or for displaying mark/Index price vs. execution price).

Funding & Skew on APT/USDC: APT/USDC being a crypto pair means funding rates can fluctuate based on long/short demand. Merkle’s docs show the formula using a Skew Factor (e.g. 2e9) and Market Skew (difference between long and short OI)
docs.merkle.trade
docs.merkle.trade
. For your guide, it’s enough to note: use Merkle’s approach by retrieving the current funding rate and accumulated funding from on-chain. For instance, the trading resource for APT/USDC will have funding_rate (possibly as an integer where 1e6 might equal 0.000001 or similar). You can convert that to an annualized rate or per-hour rate to show users. When a position is opened or closed, you might want to display the impact of funding: e.g. “Funding Fee: 0.002 USDC (paid at close)” if the position was open during a positive funding interval. This data is directly available once the position closes (from event), but for open positions you can estimate it.

Hardcoding vs Dynamic Fetch: Initially, you might simply hardcode the parameters for APT/USDC to move fast: e.g. set max leverage = 150, maintenance margin = 10%, skew factor = 2e9 (these are likely constants from docs or on-chain). However, for a production app, consider fetching these from the contract to avoid drift. The Merkle ABI has functions like set_maximum_position_collateral etc., indicating these values exist on-chain. It’s safe to assume Merkle has an admin-set config for each pair (min collateral, min size, max collateral, fees, skew factor, etc.). They might be accessible via a resource or through their SDK’s getPairInfo. For completeness, your backend could call getAllPairInfos on startup to load metadata
github.com
 and then filter the APT/USDC entry.

In summary, by focusing on APT/USDC you reduce complexity (single price feed, single set of parameters) and can even bypass multi-pair selection in the UI. Just ensure all references (module addresses, coin types) are correct for this pair. Once it works, extending to other pairs (BTC/USD, ETH/USD, etc.) would involve adding those types and perhaps a dropdown in the UI, but the flow remains the same.

Merkle Contract Reference

To integrate at a low level, it’s useful to understand Merkle’s on-chain interface. All Merkle Trade modules are published under the deployer account address noted above
docs.merkle.trade
. Important modules include:

trading – the core module containing data structures for orders and positions, and entry functions for order placement/execution. It stores all state for each trading pair (open interests, lists of user positions, etc.)
github.com
.

trading_calc – a utility module with pure functions for trading math (used for PnL, funding, etc.)
github.com
.

price_oracle – handles the price feed integration (likely Pyth/Switchboard scripts)
github.com
.

house_lp – the Liquidity Pool module (for completeness; manages the LP that takes the opposite side of trades)
github.com
.

fee_distributor, common::safe_math_u64, etc. – other support modules
github.com
github.com
.

While the Move source code is closed-source, the ABI is public. The ABI JSON outlines all structs, resources, and entry functions (you can fetch it via Aptos API or Merkle’s GitHub). For example, the ABI confirms the function signatures for things like place_order_v3 (as we utilized) and shows the event struct definitions. When decoding events or preparing transactions, refer to these definitions to ensure you pass correct types.

Decoding Event Structures

Understanding the event fields is key to interpreting on-chain data. Below is a breakdown of the PositionEvent structure (emitted to position_events on every position open/close) and what each field represents:

Field	Type	Description
uid	u64	Unique event sequence number (incremental ID for ordering).
event_type	u64	Code for the event subtype (e.g. 0=Opened, 1=UserClosed, 2=Liquidation, 3=StopLoss, 4=TakeProfit, etc.). Used to categorize the position change.
pair_type	0x1::type_info::TypeInfo	The trading pair identifier (APT/USD in our case). TypeInfo of the base asset.
collateral_type	0x1::type_info::TypeInfo	The collateral type (e.g. USDC coin TypeInfo).
user	address	The user’s Aptos address who owns the position.
order_id	u64	The ID of the order that triggered this position event. Links back to the OrderEvent.
is_long	bool	True for a Long position, False for Short.
price	u64	The execution price for this transaction. This is the oracle price used, scaled by 1e6 (e.g. if executed at $4.4055, price = 4_405_500).
original_size	u64	The position’s size (notional value in collateral units) before this event.
size_delta	u64	The change in position size from this event. For an opening, this is the new size added. For a closing, this is the amount reduced.
original_collateral	u64	The amount of collateral in the position before this event.
collateral_delta	u64	Collateral added or removed in this event. (e.g. if adding collateral, collateral_delta is positive; if closing with “keep leverage”, some collateral is removed and returned to user).
is_increase	bool	True if this event increased the position size (opening or adding collateral). False if it decreased the size (closing or collateral removal).
is_partial	bool	True if this was a partial close. False if the position was fully closed in this event. (Always false for opens/increases).
pnl_without_fee	u64	The profit or loss before fees, realized by this position change. Expressed in collateral units (e.g. in USDC minor units). If this is an open or adding collateral, this is typically 0 (no PnL realized yet). For a closing event, this is the raw PnL from price movement.
is_profit	bool	True if the PnL was positive (profit) for this event, false if negative (loss). This corresponds to pnl_without_fee.
entry_exit_fee	u64	The trading fee paid for this trade execution. This covers maker/taker fees for opening or closing. Deducted from collateral or PnL.
funding_fee	u64	The net funding fee applied to the position during this period. If the position was closed, this is the total funding paid or received while it was open. (0 for opening events.)
is_funding_fee_profit	bool	True if the funding adjustment was in the trader’s favor (they received funding – e.g. they were short with positive funding rate). False if the trader paid funding.
rollover_fee	u64	The fee for position rollover or holding (if any). Merkle may charge small fees over time; this field would capture that. Often 0 for short durations.
long_open_interest	u64	The total long open interest for this pair after this event. Useful for seeing skew. Expressed in collateral units (sum of all longs’ notional).
short_open_interest	u64	The total short open interest for this pair after this event.

Note: Many values are scaled as integers. For monetary amounts (USDC) and prices, the scaling is 1e6 (since USDC has 6 decimals) unless otherwise specified. Always convert to human-readable format (e.g., divide by 1e6) for display.

 

Other events have similar structures:

OrderEvent: likely contains order_id, user, pair_type, is_long, size, collateral, maybe order_type (market/limit) and desired price. It tells you what the user requested. If an order is canceled, a CancelOrderEvent (with that order_id) will emit.

UpdateTPSLEvent: contains user, pair_type, is_long, and the new take_profit_trigger_price and stop_loss_trigger_price set by the user (these are likely also scaled integers representing the target prices).

When decoding these events from JSON, field names might be slightly different (e.g. camelCase). Use the ABI as a reference for field ordering if needed. Merkle’s TypeScript SDK likely provides built-in decoding to friendly structures, which you can use as well.

ABI and Module Usage

For constructing transactions, you’ll use the entry functions defined in the ABI:

place_order_v3<Tpair, Tcollateral>(...args) – as discussed, to open/close trades.

cancel_order_v3<Tpair, Tcollateral>(signer, address, order_id) – to cancel an order (the address param here is probably the user’s address or referrer).

update_position_tp_sl<Tpair, Tcollateral>(signer, is_long, new_tp, new_sl) – to update SL/TP (the ABI snippet shows UpdateTPSLEvent but the function signature can be inferred similarly).

There are also admin functions (pause, set fees, etc.) which you normally won’t use; just be aware they exist in the ABI.

For integration, use the latest version of entry functions (Merkle appended _v3 to updated versions). The ABI shows older place_order and place_order_v3 – rely on _v3 for the correct param list. The Merkle team’s official SDK is a good reference for how to call these. For example, the SDK’s placeMarketOrder uses place_order_v3 under the hood with is_market=true and passes dummy values for unused params
github.com
. You can review their open-source SDK code to see exact transaction payload formats and even use it directly as a library during development to avoid mistakes.

 

Finally, always test your integration on Aptos testnet with the Merkle protocol. Verify that when you open a position via your app, you see the correct events on-chain (use Aptos explorers or API to cross-check). Ensure that decoding works – for instance, open a small long, close it, and confirm your backend records match what the explorer shows for PnL and fees. By leveraging the structured data from Merkle’s contracts and the guidelines above, you can confidently replicate Merkle Trade’s leverage trading features within your React Native application 🎉.

 

Sources:

Merkle Trade Documentation and ABI references for contract structure and events
github.com
github.com
docs.merkle.trade

Petra Wallet official docs for deep linking on mobile
petra.app
petra.app

Aptos and Merkle SDK references for transaction building and network config
github.com
github.com
github.com
Merkle Trade user docs on position management, fees, and liquidation mechanics
docs.merkle.trade
docs.merkle.trade
docs.merkle.trade
docs.merkle.trade
Merkle Trade GitHub – architecture and module descriptions
github.com
github.com
 and example execution flows
github.com
github.com
.

